---
title: 设计模式
categories:
  - 面试
tags:
  - 设计模式
  - 单例
permalink: design
date: 2018-04-14 17:47:47
---
# 设计模式的分类

根据其目的（模式是用来做什么的）可分为创建型(Creational)，结构型(Structural)和行为型(Behavioral)三种：

- 创建型模式主要用于创建对象。
- 结构型模式主要用于处理类或对象的组合。
- 行为型模式主要用于描述对类或对象怎样交互和怎样分配职责。

<!--more-->

# 创建型模式

## 单例模式(Singleton)

保证一个类仅有一个实例，并提供一个访问它的全局访问点。

### 模式动机

对于系统中的某些类来说，有且只能有一个实例。例如：一个系统只能有一个窗口管理器。系统中可以有许多打印机，但是只能有一个打印机正在工作。

### 模式定义 

单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。

单例模式的要点有三个：

1. 一是某个类只能有一个实例；
2. 是它必须自行创建这个实例；
3. 是它必须自行向整个系统提供这个实例，单例模式是一种对象创建型模式。

### 模式结构

<div align="center">{% qnimg 微信截图_20180414223904.png alt:单例模式 %}</div>

```c++
public class Singleton 
{
    //4：定义一个变量来存储创建好的类实例
    //5：因为这个变量要在静态方法中使用，所以需要加上static修饰
    private static Singleton instance = null;
    //1：私有化构造方法，便于在内部控制创建实例的数目
    private Singleton()
    {    
    }
    //2：定义一个方法来为客户端提供类实例
    //3：这个方法需要定义成类方法，也就是要加static
    public static Singleton GetInstance(){
        //6：判断存储实例的变量是否有值
        if(instance == null){
          //6.1：如果没有，就创建一个类实例，并把值赋给存储类实例的变量
          instance = new Singleton();
        }
        //6.2：如果有值，那就直接使用
        return instance;
    }
}
```

### 优缺点

- 优点
    - 提供了对唯一实例的受控访问。 
    - 由于系统中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。
    - 允许可变数目的实例。可以对单例模式进行扩展，设计指定个数的实例对象，即节省系统资源，又解决了由于单例对象共享过多有损性能的问题
- 缺点
    - 由于单例模式中没有抽象层，因此单例类的扩展有很大困难。 
    - 单例类的职责过重，在一定程度上违背了单一职责原则。因为单例模式既提供业务方法，又提供了创建对象的方法，将对象功能和创建耦合在一起。
    - 很多面向对象语言的GC垃圾回收技术，实例化的对象长期不使用，系统会认为是垃圾，自动销毁并回收资源，这将导致共享的单例对象状态的丢失。

### 模式使用

- 系统只需要一个实例对象。例如，系统要求提供一个唯一的系列号生成器或资源管理器，或资源消耗太大而只允许创建一个对象。 
- 客户调用类的单个实例只允许使用一个公共访问点。

**例子一**

问： 我的一个系统需要一些“全局”变量。学习了单例模式后，我发现可以使用一个单例类盛放所有的“全局”变量。请问这样做对吗？

答：这样做是违背单例模式的用意的。单例模式只应当在有真正的“单一实例”的需求时才可使用。

>设计得当的系统不应当有所谓的“全局”变量，这些变量一个应当放到它们所描述的实体所对应的类中去。将这些变量从它们所描述的实体类中抽出来，放到一个不相干的单例类中去，会使得这些变量产生错误的依赖关系和耦合关系。

**例子二**

问：我的一个系统需要管理与数据库的连接。学习了单例模式后，我发现可以使用一个单例类包装一个 Connection 对象，并在 finalize() 方法中关闭这个 Connection 对象。这样的话，在这个单例类的实例没有被人引用时，这个finalize()对象就会被调用，因此，Connection 对象就会被释放。这多妙啊。

答：这样做是不恰当的。除非有单一实例的需求，不然不要使用单例模式。在这里Connection 对象可以同时有几个实例共存，不需要是单一实例。

>单例模式有很多的错误使用案例都与此例子相似，它们都是试图使用单例模式管理共享资源的生命周期，这是不恰当的。

### 模式应用

- 数据库主键编号分配

### 单例模式扩展

- 高并发、线程不安全
- 懒汉式单例
- 饿汉式单例
- 单例模式—管理多个对象

**懒汉式单例**

- 单例模式在整个应用程序的生命周期中只存在一个实例
- 懒汉式单例就是这个单例类的这个唯一实例 new 是在第一次使用 GetInstance()时实例化的
- 如果不调用 GetInstance() 的话，这个实例是不会存在的，即为 null
- 形象点说呢，就是你不去动它的话，它自己是不会实例化的，所以可以称之为懒汉。
- 前面在介绍单例模式的这几个 Demo 中都是使用的懒汉式单例

```c++
public class Singleton
{
    private static Singleton singleton;
    //定义一个只读静态对象 
    //且这个对象是在程序运行时创建的 
    private static readonly object syncObject = new object();
    private Singleton()
    {}
    public static Singleton GetInstance()
    {
        //第一重 singleton == null，为了性能，解释如下
        if (singleton == null)
        {
            // 单线程
            lock (syncObject)
            {
                //第二重 singleton == null，为了单一实例
                if (singleton == null)
                {
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
```

>如果没有第一重 singleton == null 的话，每一次有线程调用GetInstance（）时，均会执行锁定操作来实现线程同步，这是非常耗费性能的。
而如果加上第一重 singleton == null 的话，那么就只有在第一次，也就是 singleton ==null 成立时的情况下执行一次锁定以实现线程同步，而以后的话，便只要直接返回 Singleton 实例就 OK 了而根本无需再进入 lock 语句块了，这样就可以解决由线程同步带来的性能问题了。

**饿汉式单例**

- 饿汉式单例的话，则刚好相反，
- 其由于肚子饿了，所以到处找东西吃，人也变得主动了很多，所以根本就不需要别人来催他实例化单例类的为一实例，
- 其自己就会主动实例化单例类的这个唯一类。

```c++
// 
public class Singleton
{
    private static readonly Singleton singleton = new Singleton();

    private Singleton()
    {
    }

    public static Singleton GetInstance()
    {
        return singleton;
    }
}
```

- C# 与 CLR 会自动解决前面提到的懒汉式单例类时出现的多线程同步问题
- 上面的饿汉式单例类中可以看到，当整个类被加载的时候，就会自行初始化 singleton 这个静态只读变量。
- 而非在第一次调用 GetInstance（）时再来实例化单例类的唯一实例，所以这就是一种饿汉式的单例类。
- 在 C# 中，可以用特殊的方式实现饿汉式单例，即使用静态初始化来完成饿汉式单例模式。

**单例模式—管理多个对象**

```c++
public class Singleton
{
    private static int maxTeacherNum = 5;
    private static IList<Singleton> Singletons;
    private Singleton()
    {  }
    public static Singleton GetInstance()
    {
        if (Singletons == null)
        {
            Singletons = new List<Singleton>();
            for (int i = 0; i < maxTeacherNum; i++)
            {
                Singletons.Add(new Singleton());
            }
        }
        Random random = new Random();
        int k = random.Next(0, maxTeacherNum);
        Console.WriteLine("ID="+ k);
        return Singletons[k];
    }
}
static void Main(string[] args)
{
    Singleton singletonOne = Singleton.GetInstance();

    for (int i = 0; i < 2; i++)
    {
        Singleton singletonTwo = Singleton.GetInstance();
        if (singletonOne.Equals(singletonTwo))
        {
            Console.WriteLine("singletonOne 和 singletonTwo 代表的是同一个实例");
        }
        else
        {
            Console.WriteLine("singletonOne 和 singletonTwo 代表的是不同实例");
        }               
    }
    Console.ReadKey();
}
```

## 工厂方法模式(Factory Method)

定义一个用于创建对象的接口，让子类决定实例化哪一个类。

### 简单工厂问题背景

```c++
class Operation
{
    public static double GetResult(double numberA, double numberB, string operate)
    {
        double result = 0;
        switch (operate)
        {
            case "+":
                result = numberA + numberB;
                break;
            case "-":
                result = numberA - numberB;
                break;
            case "*":
                result = numberA * numberB;
                break;
            case "/":
                result = numberA / numberB;
                break;
        }
        return result;
    }
}
```

Switch中添加一个分支就可以了，运算 + - * /  的代码GetResult是正确的，却需要在修改的时候暴露，违反了开放封闭原则，继续改进。

<div align="center">{% qnimg 简单工厂20180415131811.png alt:简单工厂例子未完成 %}</div>

```c++
class Operation
{
    private double _numberA = 0;
    private double _numberB = 0;

    public double NumberA
    {
        get
        { return _numberA;}
        set
        { _numberA = value;}
    }
    public double NumberB
    {
        get
        { return _numberB;}
        set
        { _numberB = value;}
    }
    public virtual double GetResult()
    {
        return 0;
    }
}

// 加法类，其他同理
class OperationAdd : Operation  
{
    public override double GetResult()
    {
        double result = 0;
        result = NumberA + NumberB;
        return result;
    }
}

// 调用
OperationAdd add = new OperationAdd();
add.NumberA = double.Parse(strNumberA);
add.NumberB = double.Parse(strNumberB);
strResult = add.GetResult().ToString();
```

设计带来的新问题：虽然满足了开放封闭原则，单一职责原则，但是对于众多类，客户端使用起来非常不方便，这时就要用到简单工厂模式，以下类来负责创建对象。

### 简单工厂范例

<div align="center">{% qnimg 微信截图20180415125801.png alt:简单工厂例子 %}</div>

```c++
class OperationFactory
{
    public static Operation createOperate(string operate)
    {
        Operation oper = null;
        switch (operate)
        {
            case "+":
                {
                    oper = new OperationAdd();
                    break;
                }
            case "-":
                {
                    oper = new OperationSub();
                    break;
                }
                ……
        }
        return oper;
    }
}

// 调用
Operation oper;
oper = OperationFactory.createOperate(strOperate);
oper.NumberA = Convert.ToDouble(strNumberA);
oper.NumberB = Convert.ToDouble(strNumberB);
strResult = oper.GetResult().ToString();
```

以上代码只需简单参数即可获得所需对象，实现对象的创建和使用的分离，这就是简单工厂模式。

### 简单工厂概述

**定义**

简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，属于类的创建型模式，通过它根据自变量的不同返回不同的类的实例。简单工厂模式专门定义一个类来负责创建其它类的实例，被创建的实例通常都具有共同的父类。

**模式结构**

<div align="center">{% qnimg 简单工厂20180415134957.png alt:简单工厂 %}</div>

```c++
public class OperationFactory //工厂角色
{
    public static Operation createOperate(string operate)
    {
        Operation oper = null;// 抽象产品角色
        switch (operate)
        {
            case "+":
                {
                    oper = new OperationAdd();// 具体产品角色
                    break;
                }
            case "-":
                {
                    oper = new OperationSub();
                    break;
                }
         }
        return oper;
    }
}
```

**优缺点**

- 优点：
    - 工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品。简单工厂模式通过这种做法实现了对象创建和使用的分离
    - 客户端代码简洁，无需知道所创建具体产品的类名，只需知道对应的参数，可以减少使用者的记忆量。
- 缺点：
    - 工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。
    - 增加了系统中类的数量，增加了系统的复杂度和理解难度。
    - 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，有可能造成工厂逻辑过于复杂，不利于扩展。
    - 简单工厂模式通常使用静态工厂方法，造成工厂角色无法形成基于继承的等级结构。

**模式应用**

- 根据各类算法的密码生成器。
- 根据各类数据进行图表绘制。

### 工厂方法问题背景

简单工厂中的工厂类随着新方法的添加需要修改代码，同样违反了开放封闭原则，抽象化如下图。

<div align="center">{% qnimg 工厂方法20180415130256.png alt:工厂方法例子 %}</div>

```c++
// 工厂方法
interface IFactory
{
    Operation CreateOperation();
}

// 专门负责生产“+”的工厂，其他同理
class AddFactory : IFactory
{
    public Operation CreateOperation()
    {
        return new OperationAdd();
    }
}

// 调用
IFactory operFactory = new AddFactory();
Operation oper = operFactory.CreateOperation();
oper.NumberA = Convert.ToDouble(strNumberA);
oper.NumberB = Convert.ToDouble(strNumberB);
strResult = oper.GetResult().ToString();
```

### 工厂方法概述

**定义**

工厂方法模式(Factory Method Pattern)：工厂方法模式又简称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态模式，属于类的创建型模式。在工厂方法模式中，父类负责定义创建对象的公共接口，而子类则负责生成具体的对象，这样做的目的是将类的实例化操作延迟到子类中完成，即由子类来决定究竟应该实例化(创建) 哪一个类。

**模式结构**

<div align="center">{% qnimg 微信截图_20180415145051.png alt:工厂方法 %}</div>

- Product：抽象产品
- ConcreteProduct：具体产品
- Factory：抽象工厂
- ConcreteFactory：具体工厂

工厂方法模式是简单工厂模式的延伸，它继承了简单工厂模式的优点，同时还弥补了简单工厂模式的不足。工厂方法模式是使用频率最高的设计模式之一，是很多开源框架和API类库的核心模式。

**优缺点**

- 优点
    - 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类被实例化这一细节，用户只需要关心所需产品对应的工厂，无需关心创建产品的细节，甚至无需知道产品类的类名。
    - 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。
    - 使用工厂方法模式的另一个优点是在系统中加入新产品时，无需修改抽象工厂和抽象产品提供的接口，无需修改客户端，也无需修改其它的具体工厂和具体产品，而只要添加一个新的具体工厂和具体产品即可。
- 缺点
    - 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，类成对增加，将导致系统设计较为庞大，且运行时系统会有额外的开销。
    - 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现的时候可能需要用到反射等技术，增加了系统的实现难度。

**模式使用**

- 不能清楚知道所必须创建的对象的类。
- 一个类希望由它的子类来指定它所创建的对象。
- 将创建对象的职责委托给多个子类中的某一个，且不同子类提供不同实现。

## 抽象工厂模式(Abstract Factory)

提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

### 问题背景

不能不换数据库？

- 以前基于Access的数据库项目，需要修改为SQL Server
- SQL语言函数不一样，参数格式不一样
- 如SQL Server中GetDate()，Access中为Now()

最简单的数据库程序

- 假定使用SQL Server数据库
- 数据库中有用户表(User)，用户类有2个字段ID和Name
- 程序中有用户管理，可以对用户添加和查询

```c++
// 用户类，假定用户只有ID 和 Name两个字段
class User
{
    private int _id;
    public int ID
    {
        get { return _id; }
        set { _id = value; }
    }

    private string _name;
    public string Name
    {
        get { return _name; }
        set { _name = value; }
    }
}

// SqlserverUser类，用于操作User表,假定用户只有新增用户和得到用户方法，具体语句省略
class SqlserverUser
{
    public void Insert(User user)
    {
        Console.WriteLine("在Sqlserver中给User表增加一条记录");
    }

    public User GetUser(int id)
    {
        Console.WriteLine("在Sqlserver中根据ID得到User表一条记录");
        return null;
    }
}

// Su对象框死在Sqlserver数据库上了，加入要换Access数据库，跟Su对象相关的代码都要修改
static void Main(string[] args)
{
    User user = new User();

    SqlserverUser su = new SqlserverUser();

    su.Insert(user);

    su.GetUser(1);

    Console.Read();
}
```

利用上面学习到的工厂方法修改代码如下：

```c++
interface IUser
{
    void Insert(User user);

    User GetUser(int id);
}
class SqlserverUser : IUser
{
    public void Insert(User user)
    {
        Console.WriteLine("在Sqlserver中给User表增加一条记录");
    }

    public User GetUser(int id)
    {
        Console.WriteLine("在Sqlserver中根据ID得到User表一条记录"); 
        return null;
    }
}
class AccessUser : IUser
{
    public void Insert(User user)
    {
        Console.WriteLine("在Access中给User表增加一条记录");
    }

    public User GetUser(int id)
    {
        Console.WriteLine("在Access中根据ID得到User表一条记录");    
        return null;
    }
}
interface IFactory
{
    IUser CreateUser();
}
class SqlServerFactory : IFactory
{
    public IUser CreateUser()
    {
        return new SqlserverUser();
    }
}
class AccessFactory : IFactory
{
    public IUser CreateUser()
    {
        return new AccessUser();
    }
}
static void Main(string[] args)
{
    User user = new User();

    IFactory factory = new AccessFactory();   //SqlServerFactory();

    IUser iu = factory.CreateUser();

    iu.Insert(user);
    iu.GetUser(1);

    Console.Read();
}
```

- 数据库只有一个表吗？
- 假如增加部门表，如何处理？

```c++
class Department
{
    private int _id;
    public int ID
    {
        get { return _id; }
        set { _id = value; }
    }

    private string _deptName;
    public string DeptName
    {
        get { return _deptName; }
        set { _deptName = value; }
    }
}
interface IDepartment
{
    void Insert(Department department);
    Department GetDepartment(int id);
}
class SqlserverDepartment : IDepartment
{
    public void Insert(Department department)
    {
        Console.WriteLine("在Sqlserver中给Department表增加一条记录");
    }
    public Department GetDepartment(int id)
    {
        Console.WriteLine("在Sqlserver中根据ID得到Department表一条记录");  return null;
    }
}
class AccessDepartment : IDepartment
{
    public void Insert(Department department)
    {
        Console.WriteLine("在Access中给Department表增加一条记录");
    }
    public Department GetDepartment(int id)
    {
        Console.WriteLine("在Access中根据ID得到Department表一条记录");   return null;
    }
}
interface IFactory
{
    IUser CreateUser();

    IDepartment CreateDepartment();
}
class SqlServerFactory : IFactory
{
    public IUser CreateUser()
    {
        return new SqlserverUser();
    }
    public IDepartment CreateDepartment()
    {
        return new SqlserverDepartment();
    }
}
class AccessFactory : IFactory
{
    public IUser CreateUser()
    {
        return new AccessUser();
    }
    public IDepartment CreateDepartment()
    {
        return new AccessDepartment();
    }
}
static void Main(string[] args)
{
    User user = new User();
    Department dept = new Department();

    IFactory factory = new AccessFactory();  //SqlServerFactory();
    
    IUser iu = factory.CreateUser();
    iu.Insert(user);
    iu.GetUser(1);

    IDepartment id = factory.CreateDepartment();
    id.Insert(dept);
    id.GetDepartment(1);

    Console.Read();
}
```

<div align="center">{% qnimg 微信截图_20180415163014.png alt:抽象工厂例子 %}</div>

以上就是抽象工厂模式。

### 模式动机

在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂方法也具有唯一性，一般情况下，一个具体工厂中只有一个工厂方法或者一组重载的工厂方法。但是有时候我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象。

### 模式定义

提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。

### 模式结构

<div align="center">{% qnimg 微信截图_20180415162141.png alt:抽象工厂 %}</div>

- AbstractFactory：抽象工厂
- ConcreteFactory：具体工厂
- AbstractProduct：抽象产品
- Product：具体产品
- Client：客户类

### 优缺点

- 优点
    - 抽象工厂模式的主要优点是隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。
    - 所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。
- 缺点
    - 抽象工厂模式的缺点是在添加新的产品对象时，难以扩展抽象工厂以便生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来很多不便。
    - 开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）

### 模式使用

- 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有形态的工厂模式都很重要。
- 系统有多于一个的产品族，而客户端只消费其中某一产品族。 
- 系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现。

## 建造者模式(Builder)

将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

### 模式背景

<div align="center">{% qnimg 微信截图_20180415164857.png alt:建造者模式 %}</div>

```c++
private void button1_Click(object sender, EventArgs e)
{
    Graphics person = pictureBox1.CreateGraphics();
    Pen p = new Pen(Color.Yellow);
    person.DrawEllipse(p, 50, 20, 30, 30);
    person.DrawRectangle(p, 60, 50, 10, 50);
    person.DrawLine(p, 60, 50, 40, 100);
    person.DrawLine(p, 70, 50, 90, 100);
    person.DrawLine(p, 60, 100, 45, 150);
    person.DrawLine(p, 70, 100, 85, 150);
}
```

需求改变，再画一个胖一点的小人

<div align="center">{% qnimg 微信截图_20180415165000.png alt:建造者模式 %}</div>

晕，少画了一条腿，难道每次都要重新写一遍代码？

如何设计？使得凡是绘制小人，都必须有头、身、两个手和两个脚？

<div align="center">{% qnimg 微信截图_20180415170236.png alt:建造者模式 %}</div>

```c++
abstract class PersonBuilder
{
    protected Graphics g;
    protected Pen p;

    public PersonBuilder(Graphics g, Pen p)
    {
        this.g = g;
        this.p = p;
    }

    public abstract void BuildHead();
    public abstract void BuildBody();
    public abstract void BuildArmLeft();
    public abstract void BuildArmRight();
    public abstract void BuildLegLeft();
    public abstract void BuildLegRight();
}
class PersonThinBuilder : PersonBuilder
{
    public PersonThinBuilder(Graphics g, Pen p)
        : base(g, p) { }        
    public override void BuildHead()
    {
        g.DrawEllipse(p, 50, 20, 30, 30);
    }
    public override void BuildBody()
    {
        g.DrawRectangle(p, 60, 50, 10, 50);
    }
    public override void BuildArmLeft()
    {
        g.DrawLine(p, 60, 50, 40, 100);
    }
    public override void BuildArmRight()
    {
        g.DrawLine(p, 70, 50, 90, 100);
    }
    public override void BuildLegLeft()
    {
        g.DrawLine(p, 60, 100, 45, 150);
    }
    public override void BuildLegRight()
    {
        g.DrawLine(p, 70, 100, 85, 150);
    }
}
class PersonFatBuilder : PersonBuilder
{
    public PersonFatBuilder(Graphics g, Pen p)
        : base(g, p) { }
    public override void BuildHead()
    {
        g.DrawEllipse(p, 50, 20, 30, 30);
    }
    public override void BuildBody()
    {
        g.DrawEllipse(p, 45, 50, 40, 50);
    }
    public override void BuildArmLeft()
    {
        g.DrawLine(p, 50, 50, 30, 100);
    }
    public override void BuildArmRight()
    {
        g.DrawLine(p, 80, 50, 100, 100);
    }
    public override void BuildLegLeft()
    {
        g.DrawLine(p, 60, 100, 45, 150);
    }
    public override void BuildLegRight()
    {
        g.DrawLine(p, 70, 100, 85, 150);
    }
}
```

继承自抽象类，如果不重写抽象方法，编译器都不通过?

```c++
private void button2_Click(object sender, EventArgs e)
{
    Pen p = new Pen(Color.Yellow);
    PersonThinBuilder thin = new PersonThinBuilder(pictureBox1.CreateGraphics(),p);
    thin.BuildHead();
    thin.BuildBody();
    thin.BuildArmLeft();
    thin.BuildArmRight();
    thin.BuildLegLeft();
    thin.BuildLegRight();

}
```

用户调用创建类对象绘制小人，还需要知道头、手、脚这些方法？以下是解决方法。

<div align="center">{% qnimg 微信截图_20180415171210.png alt:建造者模式 %}</div>

```c++
class PersonDirector
{
    private PersonBuilder pb;
    public void CreatePerson()
    {
        pb.BuildHead();
        pb.BuildBody();
        pb.BuildArmLeft();
        pb.BuildArmRight();
        pb.BuildLegLeft();
        pb.BuildLegRight();
    }
    public PersonDirector(PersonBuilder pb)
    {
        this.pb = pb;
    }
}
private void button3_Click(object sender, EventArgs e)
{
    Pen p = new Pen(Color.Yellow);
    PersonThinBuilder pb = new PersonThinBuilder(pictureBox1.CreateGraphics(), p);
    PersonDirector pd = new PersonDirector(pb);
    pd.CreatePerson();
}
private void button3_Click(object sender, EventArgs e)
{
    Pen p = new Pen(Color.Yellow);
    PersonFatBuilder pb = new PersonFatBuilder(pictureBox1.CreateGraphics(), p);
    PersonDirector pd = new PersonDirector(pb);
    pd.CreatePerson();
}
```

建造者模式中，添加了一个很重要的类，指挥者类(Director)，用它来控制建造过程，也用它来隔离用户与建造过程之间的关联

### 模式动机

在某些情况下，一个对象会有一些重要的属性，在它们没有恰当的值之前，对象不能作为一个完整的产品使用。比如，一个电子邮件有发件人地址、收件人地址、主题、内容、附录等部分，而在最起码的收件人地址未被赋值之前，这个电子邮件不能发出。

### 模式定义

将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。

### 模式结构

<div align="center">{% qnimg 微信截图_20180415172543.png alt:建造者模式 %}</div>

```c++
class Product
{
    private string partA;
    private string partB;
    private string partC;
    public string PartA
    {
        set { partA = value; }
        get { return partA; }
    }
    public string PartB
    {
        set { partB = value; }
        get { return partB; }
    }
    public string PartC
    {
        set { partC = value; }
        get { return partC; }
    }
    public void Introduce()
    {
        Console.WriteLine(PartA);
        Console.WriteLine(PartB);
        Console.WriteLine(PartC);
        Console.WriteLine();
    }
}
abstract class Builder
{
    protected Product product = new Product();
    public abstract void BuildPartA();
    public abstract void BuildPartB();
    public abstract void BuildPartC();
    public Product GetResult()
    {
        return product;
    }
}
class ConcreteBuilderOne : Builder
{
    public override void BuildPartA()
    {
        product.PartA = "Finish PartA for ProductOne";
    }
    public override void BuildPartB()
    {
        product.PartB = "Finish PartB for ProductOne";
    }
    public override void BuildPartC()
    {
        product.PartC = "Finish PartC for ProductOne";
    }
}
class ConcreteBuilderTwo : Builder
{
    public override void BuildPartA()
    {
        product.PartA = "完成第二个产品PartA";
    }
    public override void BuildPartB()
    {
        product.PartB = "完成第二个产品PartB";
    }
    public override void BuildPartC()
    {
        product.PartC = "完成第二个产品PartC";
    }
}
class Director
{
    private Builder builder;
    public Director(Builder builder)
    {
        this.builder = builder;
    }
    public void SetBuilder(Builder builder)
    {
        this.builder = builder;
    }
    public void Construct()
    {
        builder.BuildPartA();
        builder.BuildPartB();
        builder.BuildPartC();
    }
}
static void Main(string[] args)
{
    Product pt;
    Builder bd = new ConcreteBuilderOne();
    Director dt = new Director(bd);
    dt.Construct();
    pt = bd.GetResult();
    pt.Introduce();

    bd = new ConcreteBuilderTwo();
    dt.SetBuilder(bd);
    dt.Construct();
    pt = bd.GetResult();
    pt.Introduce();
    
    Console.ReadKey();
}
```

- Builder：抽象建造者
- ConcreteBuilder：具体建造者
- Director：指挥者
- Product：产品角色

<div align="center">{% qnimg 微信截图_20180415174352.png alt:建造者模式形象比喻 %}</div>

### 优缺点

- 建造者模式的使用使得产品的内部组成可以独立的变化，使用建造者模式可以使客户端不必知道产品内部组成的细节。
- 每一个Builder都相对独立，而与其他的Builder无关。
- 模式所建造的最终产品更易于控制。

### 模式使用

- 需要生成的产品对象有复杂的内部结构。
- 需要生成的产品对象的属性相互依赖，建造者模式可以强迫生成顺序。
- 在对象创建过程中会使用到系统中的一些其他对象，这些对象在产品对象的创建过程中不易得到。

### 模式应用

Mail（一步一步构造一个完整的邮件对象，然后发送）

```c++
public void set主题(String 主题) {
    this.主题 = 主题;}
public void set发件人(Email地址 发件人) {
    this.发件人 = 发件人;}
public void set抄送人(List<Email地址> 抄送人) {
    this.抄送人 = 抄送人; }
public void set收件人(List<Email地址> 收件人) {
    this.收件人 = 收件人;}
public void set正文(String 正文) {
    this.正文 = 正文;}
public void set邮件时间(Date time) {
    this.邮件时间 = time;}
public void set附件(List<File> files) {
    this.附件 = files;}
```

## 原型模式(Prototype)

用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

### 模式背景

**简历投递**

```c++
class Resume     //简历类
{  
    private string name, sex , age , timeArea, company , AimCompany;
    public Resume(string name)
    {
        this.name = name;
    }
    public void SetPersonalInfo(string sex, string age)    //设置个人信息
    {
        this.sex = sex;     this.age = age;
    }
    public void SetWorkExperience(string timeArea, string company)    //设置工作经历
    {
        this.timeArea = timeArea;     this.company = company;
    }
    public void SetAimCompany(string AimCompany)    //设置目标公司名称
    {
        this.AimCompany = AimCompany;
    }
    public void Display()     //显示
    {
        Console.WriteLine("尊敬的" + AimCompany + "公司领导，您好：")
        Console.WriteLine("{0} {1} {2}", name, sex, age);
        Console.WriteLine("工作经历：{0} {1}", timeArea, company);
    }
}
```

内容相似只能Ctrl+C, Ctrl+V?

```c++
static void Main(string[] args)
{
    Resume a = new Resume(“张三");
    a.SetPersonalInfo("男", "22");
    a.SetWorkExperience("1998-2000", “XX 公司");
    a.SetAimCompany("Google");
                
    Resume b = a;            

    a.Display();
    b.Display();

    b.SetAimCompany(“Baidu");
    
    a.Display();
    b.Display();

    Console.Read();
}
```

<div align="center">{% qnimg 微信截图_20180416124727.png alt:原型模式 %}</div> 

以下做原型模式的改进

```c++
class Resume: Icloneable //简历类
{  
    private string name, sex , age , timeArea, company , AimCompany;
    public Resume(string name)
    {
        this.name = name;
    }
    public void SetPersonalInfo(string sex, string age)    //设置个人信息
    {
        this.sex = sex;     this.age = age;
    }
    public void SetWorkExperience(string timeArea, string company)    //设置工作经历
    {
        this.timeArea = timeArea;     this.company = company;
    }
    public void SetAimCompany(string AimCompany)    //设置目标公司名称
    {
        this.AimCompany = AimCompany;
    }
    public void Display()     //显示
    {
        Console.WriteLine("尊敬的" + AimCompany + "公司领导，您好：")
        Console.WriteLine("{0} {1} {2}", name, sex, age);
        Console.WriteLine("工作经历：{0} {1}", timeArea, company);
    } 
    public Object Clone()
    {
        return this.MemberwiseClone();
    }
}

static void Main(string[] args)
{
    Resume a = new Resume(“张三");
    a.SetPersonalInfo("男", "22");
    a.SetWorkExperience("1998-2000", “XX 公司");
    a.SetAimCompany("Google");
    
    Resume b = (Resume)a.Clone();            

    a.Display();
    b.Display();

    b.SetAimCompany(“Baidu");
    
    a.Display();
    b.Display();

    Console.Read();
}
```



**配钥匙**

前几天，我很不幸把大门的钥匙给弄丢了，结果进不了家门。万幸的是，同学那儿还有一把，于是第二天我拿了他的那把去配钥匙。另外，他还让我顺便给他配一把房间的钥匙。现在配个钥匙真是简单，把钥匙给他，他直接找一个合适的钥匙胚子，把我的钥匙夹在配钥匙机的一端，胚子夹在另一端，一开电源，一把标尺比着我的钥匙齿型走一遍，砂轮就在胚子上复制出一把钥匙来！一分钟不到，两把新钥匙就搞定了！

<div align="center">{% qnimg 微信截图_20180416122107.png alt:原型模式 %}</div> 

```c++
public abstract class Key
{
    private string name;
    public string Name
    {
        get { return name; }
        set { name = value; }
    }

    private string owner;
    public string Owner
    {
        get { return owner; }
        set { owner = value; }
    }

    public Key(string name, string owner)
    {
        this.name = name;
        this.owner = owner;
    }
    //钥匙复制自身的抽象定义
    public abstract Key Clone();
    public override String ToString()
    {
        return this.Name + ", 属于 " + this.Owner;
    }
}

//大门钥匙
public class GateKey : Key
{ 
    public GateKey(string owner) : base("大门 钥匙", owner) { }

    public override Key Clone()
    {
        return new GateKey(this.Owner);
    }
}

//橱柜钥匙
public class CabinetKey : Key
{
    public CabinetKey(string owner) : base("房间 钥匙", owner) { }

    public override Key Clone()
    {
        return new CabinetKey(this.Owner);
    }
}

public static void Main(string[] args)
{
    Key oldGateKey, newGateKey, oldCabinetKey, newCabinetKey;
    oldGateKey = new GateKey("同学");
    newGateKey = oldGateKey.Clone();
    newGateKey.Owner = "我";

    oldCabinetKey = new CabinetKey("我");
    newCabinetKey = oldCabinetKey.Clone();
    newCabinetKey.Owner = "同学";

    Console.WriteLine(oldGateKey.ToString());
    Console.WriteLine(newGateKey.ToString());
    Console.WriteLine(oldCabinetKey.ToString());
    Console.WriteLine(newCabinetKey.ToString());
    Console.Read();
}

```

### 模式动机

有些对象的创建过程较为复杂，而且有时候需要频繁创建，原型模式通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象。这就是原型模式的动机。

### 模式定义

它是一种对象创建型模式，用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式允许一个对象再创建另外一个可定制的对象，无需知道任何创建的细节。

通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝原型自己来实现创建过程。

### 模式结构

<div align="center">{% qnimg 微信截图_20180416120752.png alt:原型模式 %}</div>

- Prototype：抽象原型类
- ConcretePrototype：具体原型类
- Client：客户

**抽象原型类**

```c++
abstract class Prototype
{
    private string id;

    // Constructor 
    public Prototype(string id)
    {
        this.id = id;
    }

    // Property 
    public string Id
    {
        get { return id; }
    }

    public abstract Prototype Clone();
}
```

**具体原型类**

```c++
class ConcretePrototype1 : Prototype
{
    // Constructor 
    public ConcretePrototype1(string id) : base(id)
    {
    }

    public override Prototype Clone()
    {
        // Shallow copy 
        return (Prototype) new ConcretePrototype1(this.Id);        
    }
}
```

**客户端代码**

```c++
static void Main(string[] args)
{
    Prototype p1, c1;

    p1 = new ConcretePrototype1(“Design Pattern");

    c1 = p1.Clone();

    Console.WriteLine("Cloned: {0}", c1.Id);

    Console.Read();
}
```

### 模式解析

- 对于.Net而言，其他许多语言同理，原型抽象类Prototype是用不着的，因为克隆实在太常用了，所以.Net在System命名空间中提供了Icloneable接口，其中就是一个唯一的方法Clone()，这样，只用实现这个接口就可以完成原型模式了。
- 另一方面，所有的Java类都继承自java.lang.Object，而Object类提供一个clone()方法，可以将一个Java对象复制一份。但是，这个Java类必须实现一个标识接口Cloneable，标识这个Java类支持复制。

**深克隆与浅克隆** 

接上例中的简历内容，给Resume添加一些新的内容

```c++
public class IDInfo
{
    public int IdNumber;
    public IDInfo(int IdNumber)
    {
        this.IdNumber = IdNumber;
    }
}
//简历
class Resume : ICloneable
{
    private string name;
    private string sex;
    private string age;
    private string timeArea;
    private string company;
    public IDInfo idinfo;

    public Resume(string name)
    {
        this.name = name;
        idinfo = new IDInfo(123456);
    }
    public void Display()
    {
        Console.WriteLine("尊敬的" + AimCompany + "公司领导，您好：");
        Console.WriteLine("{0} {1} {2}", name, sex, age);
        Console.WriteLine("工作经历：{0} {1}", timeArea, company);
        Console.WriteLine("ID号码:" + idinfo.IdNumber.ToString());
        Console.WriteLine("");
    }
}
static void Main(string[] args)
{
    Resume a = new Resume(“张三");
    a.SetPersonalInfo("男", "22");
    a.SetWorkExperience("1998-2000", “XX 公司");
    a.SetAimCompany("Google");
                
    Resume b = (Resume)a.Clone();            

    a.Display();
    b.Display();

    b.SetAimCompany(“Baidu");
    b.idinfo.IdNumber = 56789;
    
    a.Display();
    b.Display();

    Console.Read();
}
```

<div align="center">{% qnimg 微信截图_20180416130349.png alt:原型模式 %}</div>

结果错误！张三的ID也跟着变了！

<div align="center">{% qnimg 微信截图_20180416131200.png alt:原型模式 %}</div>

- 在浅克隆中，被复制对象的所有变量都具有与原来的对象相同的值，而所有对其它对象的引用仍然指向原来的对象。换言之，浅克隆仅仅复制所考虑的对象，而不复制它所引用的对象，也就是说其中的成员对象并不复制。在浅克隆中，当对象被复制时它所包含的成员对象却没有被复制。
- 在深克隆中，对象在复制的同时其成员对象也将复制。

```c++
// 将代码加入Resume类中
public Object DeepClone()
{
    Resume rsm = (Resume)this.MemberwiseClone();
    rsm.idinfo = new IDInfo(this.idinfo.IdNumber);
    return rsm;
}
// 调用
Resume b = (Resume)a.DeepClone();
```

### 优缺点

- 优点
    - 当创建新的对象实例较为复杂时，使用原型模式可以简化的对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。
    - 原型模式允许动态增加或减少产品类。
    - 原型模式具有给一个应用软件动态加载新功能的能力。 
    - 产品类不需要非得有任何事先确定的等级结构 。
- 缺点
    - 原型模式的最主要缺点就是每一个类必须配备一个克隆方法。而且这个克隆方法需要对类的功能进行通盘考虑，这对全新的类来说不是很难，但对已有的类进行改造时，不一定是件容易的事。
    - 原型模式的另一个缺点是在实现深克隆时需要编写较为复杂的代码。

### 模式使用

- 创建新对象成本较大(CPU，初始化)。
- 系统要保存对象的状态，对象状态变化很小。
- 当一个类的实例只有几个不同状态组合时，建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化更为方便。

### 模式应用

原型模式在很多软件都可以找到它的应用，如果实例化一个类要花大量时间，原型模式是最好的解决方案。很多软件提供的复制、粘贴功能都是原型模式的应用。类型相同，但内存地址不同的对象。

# 结构型模式

## 适配器模式(Adapter)

将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

### 问题背景

在NBA我需要翻译

- 姚明刚来到NBA，身材够高，球技够好
- 但是英语不是很懂，听不懂教练的战术安排
- 球员分为前锋、中锋和后卫
- 教练会给球员分配进攻、防守任务

<div align="center">{% qnimg 微信截图_20180416133847.png alt:原型模式 %}</div>

### 模式动机

- 通常，客户类(client of class)通过类的接口访问它提供的服务。有时现有的类(existing class)可以提供客户类的功能需要，但是它所提供的接口不一定是客户类所期望的。这是由于现有的接口名称与客户类所查找的不同等诸多不同原因导致的。 
- 在这种情况下， 现有的接口需要转化 (convert) 为客户类期望的接口，这样保证了对现有类的重用。适配器模式(Adapter Pattern)可以完成这样的转化。

### 模式定义

适配器模式(Adapter Pattern)： 将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。

### 模式结构

<div align="center">{% qnimg 微信截图_20180416135051.png alt:适配器模式 %}</div>

- Target：目标抽象类 
- Adapter：适配器类 
- Adaptee：适配者类（被适配） 
- Client：客户类

**篮球运动员**

<div align="center">{% qnimg 微信截图_20180416135031.png alt:适配器模式 %}</div>

```c++
abstract class Player    //篮球运动员
{
    protected string name;
    public Player(string name)
    {
        this.name = name;
    }
    public abstract void Attack();
    public abstract void Defense();
}
class Forwards : Player   //前锋
{
    public Forwards(string name) : base(name)
    {
    }
    public override void Attack()
    {
        Console.WriteLine("前锋 {0} 进攻", name);
    }
    public override void Defense()
    {
        Console.WriteLine("前锋 {0} 防守", name);
    }
}
class ForeignCenter   //外籍中锋
{
    private string name;
    public string Name
    {
        get { return name; }
        set { name = value; }
    }
    public void 进攻()
    {
        Console.WriteLine("外籍中锋 {0} 进攻", name);
    }
    public void 防守()
    {
        Console.WriteLine("外籍中锋 {0} 防守", name);
    }
}
static void Main(string[] args)
{
    Player pp = new Forwards("Patrick Patterson");
    pp.Attack();

    Player tw = new Guards("Terrence Williams");
    tw.Attack();

    ForeignCenter ym = new ForeignCenter("姚明");
    ym.进攻();

    Console.Read();
}
class Translator : Player   //翻译者
{
    private ForeignCenter wjzf = new ForeignCenter();

    public Translator(string name) : base(name)
    {
        wjzf.Name = name;
    }

    public override void Attack()
    {
        wjzf.进攻();
    }

    public override void Defense()
    {
        wjzf.防守();
    }
}
static void Main(string[] args)
{
    Player pp = new Forwards("Patrick Patterson");
    pp.Attack();

    Player tw = new Guards("Terrence Williams");
    tw.Attack();

    Player ym = new Translator ("姚明");
    ym.Attack ();

    Console.Read();
}
```

**鸭子适配器**

```c++
interface Duck
{
    public void quack();
    public void fly();
}
// 野鸭子类
class MallardDuck : Duck
{
    public void quack()
    {
        Console.WriteLine("嘎嘎嘎...");
    }

    public void fly()
    {
        Console.WriteLine("我在飞哦！");
    }
}
interface Turkey
{
    public void gobble();
    public void fly();
}
// 野火鸡类
class WildTurkey : Turkey
{
    public void gobble()
    {
        Console.WriteLine("咕咕咕...");
    }

    public void fly()
    {
        Console.WriteLine("我在飞，不过飞不远。");
    }
}
// 火鸡适配器
class TurkeyAdapter : Duck
{
    Turkey turkey;
    public TurkeyAdapter(Turkey turkey)
    {
        this.turkey = turkey;
    }
    public void quack()
    {
        turkey.gobble();
    }
    public void fly()
    {
        turkey.fly();
    }
}
// 使用适配器
static void Main(string[] args)
{
    MallardDuck duck = new MallardDuck();
    WildTurkey turkey = new WildTurkey();
    Duck turkeyAdapter = new TurkeyAdapter(turkey);

    turkey.gobble();
    turkey.fly();

    testDuck(duck);
    testDuck(turkeyAdapter);
}
static void testDuck(Duck duck)
{
    duck.quack();
    duck.fly();
}
```

**类适配器与对象适配器**

假设我们在软件开发中要记录日志，包括数据库记录日志DatabaseLog和文本文件记录日志WriteLog

开发过程需要引入一个新的日志接口，但新的日志接口和以前的不一样

*类适配器方式如下*

<div align="center">{% qnimg 微信截图_20180416141540.png alt:适配器模式 %}</div>

```c++
class DatabaseLogAdapter : DatabaseLog, Ilog
{
    public void Write()
    {
        this.WirteLog();
    }
}
class FileLogAdapter : FileLog, Ilog
{
    public void Write()
    {
        this.WirteLog();
    }
}
```

*对象适配器*

<div align="center">{% qnimg 微信截图_20180416141951.png alt:适配器模式 %}</div>

```c++
class LogAdapter : Ilog
{
    private Log log;
    public LogAdapter(Log log)
    {
        this.log = log;
    }
    public void Write()
    {
        log.WriteLog();
    }
}
```

上面两种适配方式，可以看出在类适配方式中，是通过类的继承来实现的，同时也具有接口ILog的所有行为，这些就违背了面向对象设计原则中的类的单一职责原则，而对象适配器则是通过对象组合的方式来实现的，则符合面向对象的精神，所以推荐用对象适配的模式。

### 优缺点

- *将目标类和适配者类解耦*，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。
- *增加了类的透明性和复用性*，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。
- *灵活性和扩展性都非常好*，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。

### 模式使用

- 系统需要使用的类的接口不符合系统的要求。
- 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。这些源类不一定有很复杂的接口。 
- （对象适配器而言）在设计里，需要改变多个已有子类的接口，如果使用类的适配器模式，就要针对每一个子类做一个适配器，而这不太实际。

## 桥接模式(Bridge)

将抽象部分与它的实现部分分离，使它们都可以独立地变化。

### 问题背景

凭什么你的手机游戏我不能玩？

- M品牌手机的游戏，N品牌不能玩
- 不同品牌手机操作系统不同，软件不通用
- 用程序模拟，N品牌手机，有一个游戏，运行游戏的程序如何写

```c++
static void Main(string[] args)
{
    MobilePhoneNGame game = new MobilePhoneNGame();
    game.Run();

    Console.Read();
}

class MobilePhoneNGame
{
    public void Run()
    {
        Console.WriteLine("运行N品牌手机游戏");
    }
}
```

如果有一个M品牌手机，也有游戏可以运行，如何设计？

```c++
class MobilePhoneGame
{
    public virtual void Run()
    {
    }
}

class MobilePhoneNGame : MobilePhoneGame
{
    public override void Run()
    {
        Console.WriteLine("运行N品牌手机游戏");
    }
}

class MobilePhoneMGame : MobilePhoneGame
{
    public override void Run()
    {
        Console.WriteLine("运行M品牌手机游戏");
    }
}
```

如果M品牌和N品牌手机，都添加了通讯录怎么办？

<div align="center">{% qnimg 微信截图_20180416151749.png alt:桥接模式 %}</div>

如果再添加Mp3音乐播放功能，怎么修改？

<div align="center">{% qnimg 微信截图_20180416151933.png alt:桥接模式 %}</div>

如果再添加S品牌手机，并且有相同功能，怎么修改？

<div align="center">{% qnimg 微信截图_20180416152431.png alt:桥接模式 %}</div>

怎么这么麻烦，换一种方式试一下

<div align="center">{% qnimg 微信截图_20180416152545.png alt:桥接模式 %}</div>

违背了面向对象单一职责原则

为什么抽象了手机品牌，或抽象了手机软件，当需求变化时，感觉如此不稳定？

### 模式动机

桥接模式的用意是“将抽象化(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立地变化”。

### 模式定义

将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。

### 解耦变化

我们需要解耦这两个方向的变化，把它们之间的强耦合关系改成弱联系。我们把手机品牌和手机软件的实现分别当作两个独立的部分来对待。

<div align="center">{% qnimg 微信截图_20180416153811.png alt:桥接模式 %}</div>

这时对于手机品牌和手机软件这两个类都可以独立的变化了！我们要做的工作就是把这两部分之间连接起来，那如何连接呢？Bridge使用了对象聚合的方式，像一座桥。

```c++
abstract class MobilePhoneSoft  //手机软件
{

    public abstract void Run();
}
class MobilePhoneGame : MobilePhoneSoft   //手机游戏
{
    public override void Run()
    {
        Console.WriteLine("运行手机游戏");
    }
}
class MobilePhoneAddressList : MobilePhoneSoft    //手机通讯录
{
    public override void Run()
    {
        Console.WriteLine("运行手机通讯录");
    }
}
class MobilePhoneMP3 : MobilePhoneSoft    //手机MP3播放
{
    public override void Run()
    {
        Console.WriteLine("运行手机MP3播放");
    }
}
abstract class MobilePhoneBrand //手机品牌
{
    protected MobilePhoneSoft soft;

    //设置手机软件
    public void SetHandsetSoft(MobilePhoneSoft soft)
    {
        this.soft = soft;
    }
    //运行
    public abstract void Run();
}
class MobilePhoneN : MobilePhoneBrand //手机品牌N
{
    public override void Run()
    {
        soft.Run();
    }
}
static void Main(string[] args)
{
    MobilePhoneBrand ab;
    ab = new MobilePhoneN();

    ab.SetHandsetSoft(new MobilePhoneGame());
    ab.Run();

    ab.SetHandsetSoft(new MobilePhoneAddressList());
    ab.Run();

    Console.Read();
}
```

### 模式结构

<div align="center">{% qnimg 微信截图_20180416154303.png alt:桥接模式 %}</div>

- Abstraction：抽象类
- RefinedAbstraction：扩充抽象类
- Implementor：实现类接口
- ConcreteImplementor：具体实现类

在桥接模式中不仅Implementor具有变化(ConcreateImplementior)，而且Abstraction也可以发生变化(RefinedAbstraction)，这是一个多对多的关系，而且两者的变化是完全独立的。RefinedAbstraction与ConcreateImplementior之间松散耦合，它们仅仅通过Abstraction与Implementor之间的聚合关系联系起来。

### 模式范例

考虑不同平台的日志记录，对于操作数据库、写入文本文件所调用的方式可能是不一样的，为此对于不同的日志记录方式，我们需要提供各种不同平台上的实现，对上面的类做进一步的设计得到了下面的结构图

<div align="center">{% qnimg 微信截图_20180416154514.png alt:桥接模式 %}</div>

现在的这种设计方案本身是没有任何错误的，假如现在我们要引入一种新的xml文件的记录方式，则上面的类结构图会变成

<div align="center">{% qnimg 微信截图_20180416154617.png alt:桥接模式 %}</div>

我们新增加了一个继承于Log基类的子类，而没有修改其它的子类，这样也符合了开放-封闭原则。如果我们引入一种新的平台，比如说我们现在开发的日志记录工具还需要支持Borland平台，此时该类结构又变成

<div align="center">{% qnimg 微信截图_20180416154718.png alt:桥接模式 %}</div>

Bridge模式粉墨登场，我们需要解耦这两个方向的变化，把它们之间的强耦合关系改成弱联系。我们把日志记录方式和不同平台上的实现分别当作两个独立的部分来对待

<div align="center">{% qnimg 微信截图_20180416154820.png alt:桥接模式 %}</div>

- 这样的设计是脆弱的，它在遵循开放-封闭原则的同时，违背了类的单一职责原则，即一个类只有一个引起它变化的原因，而这里引起Log类变化的原因却有两个，即日志记录方式的变化和日志记录平台的变化。
- 重复代码会很多，不同的日志记录方式在不同的平台上也会有一部分的代码是相同的；再次是类的结构过于复杂，继承关系太多，难于维护，最致命的一点是扩展性太差。上面我们分析的变化只是沿着某一个方向，如果变化沿着日志记录方式和不同的运行平台两个方向变化，我们会看到这个类的结构会迅速的变庞大。

### 优缺点

- 优点
    - 分离接口及其实现部分。桥接模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。 所谓抽象和实现沿着各自维度的变化，即“子类化”它们，得到各个子类之后，从而获得不同平台上的不同型号。
    - 桥接模式的应用一般在“两个非常强的变化维度”，有时候即使有两个变化的维度，但是某个方向的变化维度并不剧烈——换言之两个变化不会导致纵横交错的结果，并不一定要使用桥接模式。桥接模式提高了系统的可扩充性。
    - 实现细节对客户透明，可以对用户隐藏实现细节。 
    - 桥接模式有时候类似于多继承方案，但是多继承方案往往违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差。桥接模式是比多继承方案更好的解决方法。

### 模式使用

- 如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性， 避免在两个层次之间建立静态的联系。 
- 设计要求实现化角色的任何改变不应当影响客户端，或者说实现化角色的改变对客户端是完全透明的。 
- 一个构件有多于一个的抽象化角色和实现化角色，系统需要它们之间进行动态耦合。 
- 虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。

### 模式应用

<div align="center">{% qnimg 微信截图_20180416155625.png alt:桥接模式 %}</div>

## 组合模式(Composite)

将对象组合成树形结构以表示"部分-整体"的层次结构，"Composite使得用户对单个对象和组合对象的使用具有一致性。"

### 模式背景

设计一个绘图程序

- 绘制基本图元线对象(Line)、圆对象(Circle)、矩形对象(Rectangle)
- 绘制组合对象(Picture)，可包含任意基本图元的组合

```c++
public class Line
{
    public void Draw()
    {
        Console.WriteLine("Draw a Line");
    }
}

public class Circle
{
    public void Draw()
    {
        Console.WriteLine("Draw a Circle");
    }
}

public class Rectangle
{
    public void Draw()
    {
        Console.WriteLine("Draw a Rectangle");
    }
}

public class Picture
{
    protected ArrayList picList = new ArrayList();

    public void Add(object pic)
    {
        picList.Add(pic);
    }
    public void Remove(object pic)
    {
        picList.Remove(pic);
    }
    public ArrayList GetChilds()
    {
        return picList;
    }
}

static void Main(string[] args)
{
    Picture root = new Picture();
    Picture branch1 = new Picture();
    Picture branch2 = new Picture();

    Line line1 = new Line();
    Circle circle1 = new Circle();
    Rectangle rect1 = new Rectangle();

    Line line2 = new Line();
    Circle circle2 = new Circle();
    Rectangle rect2 = new Rectangle();

    root.Add(line1);
    root.Add(circle1);
    root.Add(branch1);
    branch1.Add(line2);
    branch1.Add(branch2);
    branch2.Add(circle2);
    branch2.Add(rect2);
    root.Add(rect1);

    Display(root.GetChilds());

    Console.Read();
}
public static void Display(ArrayList root)
{
    for (int i = 0; i < root.Count; i++)
    {
        if (root[i] is Line)
        {
            ((Line)root[i]).Draw();
        }
        else if (root[i] is Circle)
        {
            ((Circle)root[i]).Draw();
        }
        else if (root[i] is Rectangle)
        {
            ((Rectangle)root[i]).Draw();
        }
        else if (root[i] is Picture)
        {
            Display(((Picture)root[i]).GetChilds());
        }
    }
}
```

实现判断太麻烦！

<div align="center">{% qnimg 微信截图_20180416161233.png alt:桥接模式 %}</div>

```c++
public abstract class Graphics
{
    public abstract void Draw();
}

public class Line : Graphics
{
    public override void Draw()
    {
        Console.WriteLine("Draw a Line");
    }
}

public class Circle : Graphics
{
    public override void Draw()
    {
        Console.WriteLine("Draw a Circle");
    }
}

public class Rectangle : Graphics
{
    public override void Draw()
    {
        Console.WriteLine("Draw a Rectangle");
    }
}

public class Picture : Graphics
{
    protected ArrayList picList = new ArrayList();

    public override void Draw()
    {
        Display(picList);
    }
    public void Display(ArrayList root)
    {
        for (int i = 0; i < root.Count; i++)
        {
            if (root[i] is Line)
            {
                ((Line)root[i]).Draw();
            }
            else if (root[i] is Circle)
            {
                ((Circle)root[i]).Draw();
            }
            else if (root[i] is Rectangle)
            {
                ((Rectangle)root[i]).Draw();
            }
            else if (root[i] is Picture)
            {
                Display(((Picture)root[i]).GetChilds());
            }
        }
    }
}

static void Main(string[] args)
{
    Picture root = new Picture();
    Picture branch1 = new Picture();
    Picture branch2 = new Picture();

    Line line1 = new Line();
    Circle circle1 = new Circle();
    Rectangle rect1 = new Rectangle();

    Line line2 = new Line();
    Circle circle2 = new Circle();
    Rectangle rect2 = new Rectangle();

    root.Add(line1);
    root.Add(circle1);
    root.Add(branch1);
    branch1.Add(line2);
    branch1.Add(branch2);
    branch2.Add(circle2);
    branch2.Add(rect2);
    root.Add(rect1);

    root.Draw();

    Console.Read();
}
```

拥有了公共的Draw方法，统一了绘制图形接口

以上代码没有错误，就是优秀的设计吗？

可以将判断代码依赖于抽象编程，将类型转换为抽象类Graphics

```c++
public class Picture : Graphics
{
    protected ArrayList picList = new ArrayList();

    public override void Draw()
    {
        for (int i = 0; i < picList.Count; i++)
        {
            ((Graphics)picList[i]).Draw();
        }
    }
}
```

这种思想就是组合模式。

### 模式动机

- 对于树形结构，当容器对象（如文件夹）的某一个方法被调用时，将遍历整个树形结构，寻找也包含这个方法的成员对象（可以是容器对象，也可以是叶子对象，如子文件夹和文件）并调用执行。（递归调用）
- 由于容器对象和叶子对象在功能上的区别，在使用这些对象的客户端代码中必须有区别地对待容器对象和叶子对象，而对于这些对象的区别对待将会使得程序非常复杂。
- 组合模式描述了如何将容器对象和叶子对象进行递归组合，使得用户在使用时无须对它们进行区分，可以一致地对待容器对象和叶子对象，这就是组合模式的模式动机。

### 模式定义

组合多个对象形成树形结构以表示“整体—部分”的结构层次。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性。组合模式又可以称为“整体—部分”(Part-Whole)模式，属于对象的结构模式，它将对象组织到树结构中，可以用来描述整体与部分的关系。

<div align="center">{% qnimg 微信截图_20180416164242.png alt:桥接模式 %}</div>

- Component：抽象构件（接口或抽象类） 
- Leaf：叶子构件 
- Composite：容器构件 
- Client：客户类

应该是在Graphic(Component)中声明这些集合操作，并使得这些操作对Leaf类有意义，还是只应该在Picture(Composite)和它的子类中声明并定义这些操作呢？这就要分为以下两种方式。

**安全方式**

<div align="center">{% qnimg 微信截图_20180416164816.png alt:桥接模式 %}</div>

在Composite类中定义管理子部件的方法具有良好的安全性，因为在C++这样的静态类型语言中，在编译时任何从Leaf中增加或删除对象的尝试都将被发现。但是这又损失了透明性，因为Leaf和Composite显然具有不同的接口。

**透明方式**

<div align="center">{% qnimg 微信截图_20180416164944.png alt:桥接模式 %}</div>

在类层级结构的根部定义子节点管理接口的方法具有良好的透明性，因为你可以一致地使用所有的组件，但是这一方法以安全性为代价，因为客户有可能会做一些无意义的事情，例如在Leaf中增加和删除对象。

### 优缺点

- 优点
    - 使客户端调用简单，客户端可以一致的使用组合结构或其中单个对象，用户就不必关系自己处理的是单个对象还是整个组合结构，这就简化了客户端代码。
    - 定义了包含叶子对象和容器对象的类层次结构，叶子对象可以被组合成更复杂的容器对象，而这个容器对象又可以被组合，这样不断地递归下去。客户代码中，任何用到叶子对象的地方都可以使用容器对象。 
    - 客户端不必因为加入了新的对象构件而更改代码。
- 缺点
    - 组合模式的缺陷是使得设计变得更加抽象，对象的商业规则如果很复杂，则实现组合模式较困难。
    - 此外，不是所有的方法都与叶子构件子类都有关联
    - 有时候我们希望一个容器中只能有某些特定的构件。使用组合模式时，不能依赖类型系统来施加这些约束，因为它们都来自于相同的抽象层，在这种情况下，必须通过在运行时进行类型检查来实现。

### 模式使用

- 需要表示一个对象整体或部分层次。 
- 想让客户能够忽略不同对象层次的变化。 
- 对象的结构是动态的并且复杂程度不一样，但客户需要一致地处理它们。

### 模式应用

**XML文档解析**

<div align="center">{% qnimg 微信截图_20180416165525.png alt:桥接模式 %}</div>

**文件目录操作**

操作系统中的目录结构是一个树形结构，因此在对文件和文件夹进行操作时可以应用组合模式，例如杀毒软件在查毒或杀毒时，既可以针对一个具体文件，也可以针对一个目录。如果是对目录查毒或杀毒，将递归处理目录中的每一个子目录和文件。 

## 装饰模式(Decorator)

动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活

### 模式背景

<div align="center">{% qnimg 微信截图_20180416172449.png alt:装饰模式 %}</div>

```c++
class Person
{
    private string name;
    public Person(string name)
    {
        this.name = name;
    }
    public void WearTShirts()
    {
        Console.Write("T恤 ");
    }
    public void WearJeans()
    {
        Console.Write("牛仔裤 ");
    }
    public void WearSneakers()
    {
        Console.Write("球鞋 ");
    }
    public void WearSuit()
    {
        Console.Write("西装 ");
    }
    public void WearTrousers()
    {
        Console.Write("西裤 ");
    }
    public void WearLeatherShoes()
    {
        Console.Write("皮鞋 ");
    }
    public void Show()
    {
        Console.WriteLine("装扮的{0}", name);
    }
}
static void Main(string[] args)
{
    Person zs = new Person("张三");

    Console.WriteLine("\n第一种装扮：");
    zs.WearTShirts();
    zs.WearJeans();
    zs.WearSneakers();
    zs.Show();

    Console.WriteLine("\n第二种装扮：");
    zs.WearSuit();
    zs.WearTrousers();
    zs.WearLeatherShoes();
    zs.Show();

    Console.Read();
}
```

不断添加新的衣服怎么办? 原则?

<div align="center">{% qnimg 微信截图_20180416173121.png alt:装饰模式 %}</div>

```c++
class Person
{
    private string name;
    public Person(string name)
    {
        this.name = name;
    }

    public void Show()
    {
        Console.WriteLine("装扮的{0}", name);
    }
}
abstract class Finery   //服饰
{
    public abstract void Show();
}

class TShirts : Finery   //T恤
{
    public override void Show()
    {
        Console.Write("T恤 ");
    }
}
class Jeans : Finery   //牛仔裤
{
    public override void Show()
    {

        Console.Write("牛仔裤 ");
    }
}
class Sneakers : Finery   //球鞋
{
    public override void Show()
    {

        Console.Write("球鞋 ");
    }
}
static void Main(string[] args)
{
    Person zs = new Person("张三");

    Console.WriteLine("\n第一种装扮：");
    Finery tx = new TShirts();
    Finery nzk = new Jeans();
    Finery qx = new Sneakers();

    tx.Show();
    nzk.Show();
    qx.Show();
    zs.Show();

    Console.WriteLine("\n第二种装扮：");
    Finery xz = new Suit();
    Finery xk = new Trousers();
    Finery px = new LeatherShoes();

    xz.Show();
    xk.Show();
    px.Show();
    zs.Show();

    Console.Read();
}
```

期望：内部组装完毕，再显示出来，这就要用到装饰模式。

### 模式动机

- 有时我们希望给某个对象而不是整个类添加一些功能。例如：一个图形用户界面工具箱允许我们对任意一个用户界面组件添加一些新的特性，如增加一个边框；或者增加一些行为，如窗口的滚动。 
- 一种较为灵活的方式是将组件嵌入另一个对象中，由这个对象来添加边框。我们称这个嵌入的对象为装饰器（Decorator）。这个装饰与它所装饰的组件接口一致，因此它对使用该组件的客户透明。它将客户请求转发给该组件，并且可能在转发前后执行一些额外的动作。这种透明性使得我们可以递归嵌套多个装饰，从而可以添加任意多的功能。

### 模式定义

动态地给一个对象增加一些额外的职责（Responsibility），就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名为包装器(Wrapper)。装饰模式是一种对象结构型模 式。

### 模式结构

<div align="center">{% qnimg 微信截图_20180416173909.png alt:装饰模式 %}</div>

- Component：组件 
- ConcreteComponent：具体组件 
- Decorator：抽象装饰类 
- ConcreteDecorator：具体装饰类

**穿衣服**

<div align="center">{% qnimg 微信截图_20180416174138.png alt:装饰模式 %}</div>

```c++
abstract class Appearance
{
    public abstract void Show();
}
class Person : Appearance
{
    private string name;

    public Person(string name)
    {
        this.name = name;
    }

    public override void Show()
    {
        Console.WriteLine("装扮的{0}", name);
    }
}
abstract class Finery : Appearance
{
    protected Appearance component;

    public void Decorate(Appearance component) 
    {
        this.component = component;
    }

    public override void Show()
    {
        if (component != null)
        {
            component.Show();
        }
    }
}
class TShirts : Finery
{
    public override void Show()
    {
        base.Show();            
        Console.Write("T恤");
        
    }
}
class Jeans : Finery
{
    public override void Show()
    {
        base.Show();             
        Console.Write("牛仔裤");
    }
}
class Sneakers : Finery
{
    public override void Show()
    {
        base.Show();
        Console.Write("球鞋");
    }
}
static void Main(string[] args)
{
    Person xc = new Person("小菜");

    Console.WriteLine("\n第一种装扮：");

    Sneakers qx = new Sneakers();
    Jeans nzk = new Jeans();
    TShirts tx = new TShirts();

    tx.Decorate(xc);
    nzk.Decorate(tx);
    qx.Decorate(nzk);

    qx.Show();

    Console.Read();
}
```

### 模式应用

**星巴克咖啡订单管理系统管理**

- 如果有一张订单：“双倍摩卡豆浆奶泡拿铁咖啡”，应该如何进行设计？
- 如果有一张订单：“奶泡摩卡加冰浓缩咖啡”，应该如何进行设计？

*实现一*

类爆炸

- 调料的增加/删除
- 调料价格的修改

<div align="center">{% qnimg 微信截图_20180416175157.png alt:装饰模式 %}</div>

*实现二*

使用实例变量和继承，跟踪这些调料

<div align="center">{% qnimg 微信截图_20180416175322.png alt:装饰模式 %}</div>

*实现三*

应用以上的装饰模式

<div align="center">{% qnimg 微信截图_20180416175553.png alt:装饰模式 %}</div>

### 优缺点

- 优点
    - 装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。 
    - 通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。 
    - 这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错。
- 缺点
    - 采用装饰模式进行系统设计往往会产生许多看上去类似的小对象，这些对象仅仅在他们相互连接的方式上有所不同，而不是它们的类或是它们的属性值有所不同。尽管对于那些了解这些系统的人来说，很容易对它们进行定制，但是很难学习这些系统，排错也很困难。

### 模式使用

- 在不影响其它对象的情况下，以动态、透明的方式给单个对象添加职责。 需要动态地给一个对象增加功能，这些功能可以再动态地被撤销。 
- 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义不能继承(final类)，或类不能用于生成子类。

### 需要注意的问题

- 一个装饰类的接口必须与被装饰类的接口保持相同，对于客户端来说无论是装饰之前的对象还是装饰之后的对象都可以一致对待。
- 尽量保持具体构件类Component作为一个“轻”类，也就是说不要把太多的逻辑和状态放在具体构件类中，可以通过装饰类对其进行扩展。

## 外观模式(Facade)

为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

### 模式背景

当客户来进行抵押贷款时，有如下几件事情需要确认：

1. 到银行子系统查询他是否有足够多的存款
2. 到信用子系统查询他是否有良好的信用
3. 到贷款子系统查询他有无贷款劣迹

只有这三个子系统都通过时才可进行抵押。

<div align="center">{% qnimg 微信截图_20180416214717.png alt:外观模式 %}</div>

```c++
//顾客类
public class Customer
{
    private string _name;

    public Customer(string name)
    {
        this._name = name;
    }

    public string Name
    {
        get { return _name; }
    }
}
public class Bank  //银行子系统
{
    public bool HasSufficientSavings(Customer c, int amount)
    {
        Console.WriteLine("查询银行信息，客户名 " + c.Name);
        return true;
    }
}
public class Credit   //信用子系统
{
    public bool HasGoodCredit(Customer c)
    {
        Console.WriteLine("查询信用信息，客户名 " + c.Name);
        return true;
    }
}
public class Loan   //贷款子系统
{
    public bool HasNoBadLoans(Customer c)
    {
        Console.WriteLine("查询贷款信息，客户名 " + c.Name);
        return true;
    }
}
static void Main(string[] args)
{
    Bank bank = new Bank();
    Loan loan = new Loan();
    Credit credit = new Credit();
    int Money = 12000;
    Customer customer = new Customer("张三");
    bool eligible = true;
    
    if (!bank.HasSufficientSavings(customer, Money))
    {
        eligible = false;
    }
    else if (!loan.HasNoBadLoans(customer))
    {
        eligible = false;
    }
    else if (!credit.HasGoodCredit(customer))
    {
        eligible = false;
    }

    Console.WriteLine("客户 " + customer.Name + " 已经被 " + (eligible ? "通过" : "拒绝"));
    Console.ReadLine();
}
```

可以看到，客户程序与三个子系统都发生了耦合，这种耦合使得客户程序依赖于子系统，当子系统变化时，客户程序也将面临很多变化的挑战。

### 模式动机

- 将一个系统划分为若干个子系统有利于降低系统的复杂性，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是引入一个外观对象，它为子系统中较一般的设置提供了一个单一而简单的界面。
- 外观模式要求一个子系统的外部与其内部的通信必须通过一个统一的外观(Facade)对象进行。就如同医院的接待员一样，外观模式的外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。
- 在没有外观类(Facade)之前，客户类(Client)需要和子系统类(Subsystem)进行复杂的交互，系统的耦合度很大；而增加一个外观类之后，客户类只需要直接和外观类交互，子系统类之间的复杂关系由外观类来实现，从而降低了系统的耦合度。

### 模式定义

外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式是对象的结构模式。

<div align="center">{% qnimg 微信截图_20180416220421.png alt:外观模式 %}</div>

```c++
public class Mortgage     //外观类
{
    private Bank bank = new Bank();
    private Loan loan = new Loan();
    private Credit credit = new Credit();

    public bool IsEligible(Customer cust, int amount)
    {
        Console.WriteLine("{0} 申请 {1:C} 贷款 ", cust.Name, amount);

        bool eligible = true;

        if (!bank.HasSufficientSavings(cust, amount))
        {
            eligible = false;
        }
        else if (!loan.HasNoBadLoans(cust))
        {
            eligible = false;
        }
        else if (!credit.HasGoodCredit(cust))
        {
            eligible = false;
        }

        return eligible;
    }
}
static void Main(string[] args)
{
    Mortgage mortgage = new Mortgage();   //外观

    Customer customer = new Customer("张三");
    bool eligable = mortgage.IsEligible(customer, 125000);

    Console.WriteLine("客户 " +customer.Name+" 已经被 "+(eligable ? "通过" : "拒绝"));
    Console.ReadLine();
}
```

引入Facade模式后，客户程序只与Mortgage发生依赖，也就是Mortgage屏蔽了子系统之间的复杂的操作，达到了解耦内部子系统与客户程序之间的依赖。

### 模式结构

<div align="center">{% qnimg 微信截图_20180416235335.png alt:外观模式 %}</div>

- Facade：外观角色 
- SubSystem：子系统角色

**保安系统**

一个保安系统由两个录像机、三个电灯、一个遥感器和一个警报器组成。保安系统的操作人员需要经常将这些仪器启动和关闭。

<div align="center">{% qnimg 微信截图_20180417000758.png alt:外观模式 %}</div>

Client对象需要引用到所有的录像机(Camera)、电灯(Light)、感应器(Sensor)和警报器(Alarm)对象。

```c++
public class Camera
{
    public void TurnOn()
    {
        Console.WriteLine("Turning on the camera.");
    }
    public void TurnOff()
    {
        Console.WriteLine("Turning off the camera.");
    }
    public void Rotate(int degrees){
        Console.WriteLine("Rotating the camera by {0} degrees.", degrees);
    }
} 
public class Light
{
    public void TurnOff()
    {
        Console.WriteLine("Turning on the light.");
    }
    public void TurnOn()
    {
        Console.WriteLine("Turning off the light.");
    }
    public void ChangeBulb()
    {
        Console.WriteLine("changing the light-bulb.");
    }
} 
public class Sensor
{
    public void Activate()
    {
        Console.WriteLine("Activating the sensor.");
    }
    public void Deactivate()
    {
        Console.WriteLine("Deactivating the sensor.");
    }
    public void Trigger()
    {
        Console.WriteLine("The sensor has triggered.");
    }
}
public static void Main( string[] args ){
    private static Camera camera1, camera2;
    private static Light light1, light2, light3;
    private static Sensor sensor;
    private static Alarm alarm;
    camera1 = new Camera();
    camera2 = new Camera();
    light1 = new Light();
    light2 = new Light();
    light3 = new Light();
    sensor = new Sensor();
    alarm = new Alarm();
    camera1.TurnOn();
    camera2.TurnOn();
    light1.TurnOn();
    light2.TurnOn();
    light3.TurnOn();
    sensor.Activate();
    alarm.Activate();
} 
```

一个合情合理的改进方法就是准备一个系统的控制台，作为保安系统的用户界面。

<div align="center">{% qnimg 微信截图_20180417002439.png alt:外观模式 %}</div>

```c++
public class SecurityFacade
{
    private static Camera camera1, camera2;
    private static Light light1, light2, light3;
    private static Sensor sensor;
    private static Alarm alarm;
    static SecurityFacade()
    {
        camera1 = new Camera();
        camera2 = new Camera();
        light1 = new Light();
        light2 = new Light();
        light3 = new Light();
        sensor = new Sensor();
        alarm = new Alarm();
    }
    public void Activate()
    {
        camera1.TurnOn();
        camera2.TurnOn();
        light1.TurnOn();
        light2.TurnOn();
        light3.TurnOn();
        sensor.Activate();
        alarm.Activate();
    }
    public void Deactivate()
    {
        camera1.TurnOff();
        camera2.TurnOff();
        light1.TurnOff();
        light2.TurnOff();
        light3.TurnOff();
        sensor.Deactivate();
        alarm.Deactivate();
    }
} 
public static void Main( string[] args )
{
    private static SecurityFacade security;
    security = new SecurityFacade();
    security.Activate();
    Console.WriteLine("\n--------------------\n");
    security.Deactivate();
} 
```

### 优缺点

- 它对客户屏蔽子系统组件，减少了客户处理的对象数目使得子系统使用起来更加容易。 
- 它实现了子系统与客户之间的松耦合关系。这使得子系统的组件变化不会影响到它的客户。 
- 提高了安全性，通过外观模式，屏蔽子系统业务逻辑。
- 它简化了系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其它的子系统。 
- 它并不限制复杂应用使用子系统类。 
- 外观模式并不增加任何功能性模式，它仅仅是一些简单化接口。

### 模式使用

- 当要为一个复杂子系统提供一个简单接口时。这个接口对大多数用户来说已经足够好；那些需要更多可定制性的用户可以越过Facade层。 
- 子系统相对独立——外界只需黑箱操作即可。例如利息计算。 
- 预防操作人员带来的风险扩散。

### 模式应用

- 子系统可以有多个外观。
- 外观不参与子系统的业务逻辑。

## 享元模式(Flyweight)

运用共享技术有效地支持大量细粒度的对象。

### 模式背景

<div align="center">{% qnimg 微信截图_20180417004543.png alt:享元模式 %}</div>

如何设计能有效减少系统开销?

```c++
class Game  //游戏
{
    private string name = "";
    public Game(string name)
    {
        this.name = name;
    }

    public void Play()
    {
        Console.WriteLine("运行游戏：" + name);
    }
}
static void Main(string[] args)
{
    Game zs = new Game("斗地主");
    zs.Play();

    Game ls = new Game("斗地主");
    ls.Play();

    Game ww = new Game("斗地主");
    ww.Play();

    Game zl = new Game("麻将");
    zl.Play();

    Game sq = new Game("麻将");
    sq.Play();

    Game zb = new Game("麻将");
    zb.Play();

    Console.Read();
}
```

三个斗地主实例，本质都是一样的代码，但是随着用户增多，实例也会增多，对服务器资源造成浪费，希望共享代码

### 享元模式

- 享元模式对那些通常因为数量太大而难以用对象来表示的概念或实体进行建模。
- 如为字母表中的每一个字符创建一个享元，每个享元对象存储一个字符代码。逻辑上，文档中的给定字符每次出现都有一个对象与其对应，然而物理上相同的字符共享一个享元对象，而这个对象可以出现在文档结构的不同地方。
- 由于不同的字符对象数远小于文档中的字符数，因此，对象的总数远小于一个初次执行的程序所使用的对象数目。对于一个所有字符都使用同样的字体和颜色的文档而言，不管这个文档有多长，只需要分配100个左右的字符对象（大约是ASCII字符集的数目）。由于大多数文档使用的字体颜色的组合不超过10 种，实际应用中这一数目不会明显增加。因此，对单个字符进行对象抽象是具有实际意义的。

### 模式定义

运用共享技术有效地支持大量细粒度的对象。 系统只使用少量的对象，而这些对象都很近，状态变化很小，对象使用次数增多。享元模式是一种对象结构型模式。

<div align="center">{% qnimg 微信截图_20180417010630.png alt:享元模式 %}</div>

```c++
abstract class Game   //游戏
{
    public abstract void Play();
}
class ConcreteGame : Game //具体的游戏
{
    private string name = "";
    public ConcreteGame(string name)
    {
        this.name = name;
    }

    public override void Play()
    {
        Console.WriteLine("运行游戏：" + name);
    }
}
class GameFactory   //游戏工厂
{
    private Hashtable flyweights = new Hashtable();

    //获得游戏分类
    public Game GetGameCategory(string key)
    {
        if (!flyweights.ContainsKey(key))
            flyweights.Add(key, new ConcreteGame(key));
        return ((Game)flyweights[key]);
    }

    //获得游戏分类总数
    public int GetGameCount()
    {
        return flyweights.Count;
    }
}
static void Main(string[] args)
{

    GameFactory f = new GameFactory();

    Game zs = f.GetGameCategory("斗地主");
    zs.Play();
    Game ls = f.GetGameCategory("斗地主");
    ls.Play();
    Game ww = f.GetGameCategory("斗地主");
    ww.Play();
    Game zl = f.GetGameCategory("麻将");
    zl.Play();
    Game sq = f.GetGameCategory("麻将");
    sq.Play();
    Game zb = f.GetGameCategory("麻将");
    zb.Play();
    Console.WriteLine("游戏逻辑总数为 {0}", f.GetGameCount());

    Console.Read();
}
```

- 实现了享元模式共享的目的，无论几个用户，运行游戏一样，就只保留一个游戏逻辑代码。
- 但是，这些用户毕竟不是同一个用户，用户名不同，用户的牌也不同。
- 我们称享元对象内部不随环境变化的共享部分称为内部状态。
- 而随环境而改变，不可以共享的称为外部状态。

<div align="center">{% qnimg 微信截图_20180417011251.png alt:享元模式 %}</div>

```c++
public class User //用户
{
    private string name;

    public User(string name)
    {
        this.name = name;
    }

    public string Name
    {
        get { return name; }
    }
}
abstract class Game   //游戏
{
    public abstract void Play(User user);
}
class ConcreteGame : Game //具体的游戏
{
    private string name = "";
    public ConcreteGame(string name)
    {
        this.name = name;
    }

    public override void Play(User user)
    {
        Console.WriteLine("运行游戏：" + name + " 用户：" + user.Name);
    }
}
static void Main(string[] args)
{
    GameFactory f = new GameFactory();

    Game zs = f.GetGameCategory("斗地主");
    zs.Play(new User("张三"));
    Game ls = f.GetGameCategory("斗地主");
    ls.Play(new User("李四"));
    Game ww = f.GetGameCategory("斗地主");
    ww.Play(new User("王五"));
    Game zl = f.GetGameCategory("麻将");
    zl.Play(new User("赵六"));
    Game sq = f.GetGameCategory("麻将");
    sq.Play(new User("孙七"));
    Game zb = f.GetGameCategory("麻将");
    zb.Play(new User("周八"));

    Console.WriteLine("游戏逻辑总数为 {0}", f.GetGameCount());

    Console.Read();
}
```

### 模式结构

<div align="center">{% qnimg 微信截图_20180417013418.png alt:享元模式 %}</div>

- Flyweight：抽象享元类 
- ConcreteFlyweight：具体享元类 
- UnsharedConcreteFlyweight：非共享具体享元类 
- FlyweightFactory：享元工厂类 
- Client：客户类

### 优缺点

- 大幅度地降低内存中对象的数量。
- 使得系统更加复杂。 
- 为了使对象可以共享，需要将一些状态外部化，这使得程序的逻辑复杂化。
- 享元模式将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。

### 模式使用

- 一个系统有大量的对象，造成耗费大量的内存。 
- 这些对象的状态中的大部分都可以外部化。 
- 这些对象可以按照内部状态分成很多的组，当把外部对象从对象中剔除时，每一个组都可以用相对较少的共享对象代替。 
- 软件系统不依赖于这些对象的身份，换言之，这些对象可以是不可分辨的。

### 模式应用

- 在编辑器软件中大量使用，如在一个文档中多次出现相同的图片，则只需要创建一个图片对象，通过在应用程序中设置该图片出现的位置，可以实现该图片在不同地方多次重复显示。
- Windows DLL(动态链接库)
- String类型

## 代理模式(Proxy)

为其他对象提供一种代理以控制对这个对象的访问。

### 模式使用

```c++
//快递工作人员
class ExpressPerson
{
    private string name;
    public string Name
    {
        get { return name; }
        set { name = value; }
    }
}
//毕业生
class Graduate
{
    ExpressPerson YDY;
    public Graduate(ExpressPerson YDY)
    {
        this.YDY = YDY;
    }
    public void GiveComputer()
    {
        Console.WriteLine(YDY.Name + " 请你托运计算机");
    }
    public void GiveBaggage()
    {
        Console.WriteLine(YDY.Name + " 请你托运行李");
    }
}
static void Main(string[] args)
{
    ExpressPerson YDY = new ExpressPerson();
    YDY.Name = "宅急送";

    Graduate zhangsan = new Graduate(YDY);

    zhangsan.GiveComputer();
    zhangsan.GiveBaggage();

    Console.Read();
}
//女同学
class Classmate
{
    ExpressPerson YDY;
    public Classmate(ExpressPerson YDY)
    {
        this.YDY = YDY;
    }
    public void GiveComputer()
    {
        Console.WriteLine(YDY.Name + " 请你托运计算机");
    }
    public void GiveBaggage()
    {
        Console.WriteLine(YDY.Name + " 请你托运行李");
    }
}
static void Main(string[] args)
{
    ExpressPerson YDY = new ExpressPerson();
    YDY.Name = "宅急送";

    Classmate Girl = new Classmate(YDY);

    Girl.GiveComputer();
    Girl.GiveBaggage();

    Console.Read();
}
```

以上代码复用性太低，有何解决办法？

<div align="center">{% qnimg 微信截图_20180417130415.png alt:享元模式 %}</div>

```c++
//寄东西
interface GiveObject
{
    void GiveComputer();
    void GiveBaggage();
}
//毕业生
class Graduate : GiveObject
{
    ExpressPerson YDY;
    public Graduate(ExpressPerson YDY)
    {
        this.YDY = YDY;
    }
    public void GiveComputer()
    {
        Console.WriteLine(YDY.Name + " 请你托运计算机");
    }
    public void GiveBaggage()
    {
        Console.WriteLine(YDY.Name + " 请你托运行李");
    }
}
//女同学 : GiveGift
class Classmate : GiveObject
{
    Graduate zhangsan;
    public Classmate(ExpressPerson YDY)
    {
        zhangsan = new Graduate(YDY);
    }
    public void GiveComputer()
    {
        zhangsan.GiveComputer();
    }
    public void GiveBaggage()
    {
        zhangsan.GiveBaggage();
    }
}
static void Main(string[] args)
{
    ExpressPerson YDY = new ExpressPerson();
    YDY.Name = "宅急送";

    Classmate Girl = new Classmate(YDY);

    Girl.GiveComputer();
    Girl.GiveBaggage();

    Console.Read();
}
```

以上代码就是代理模式，复用了中介的功能。

### 模式动机

一个客户不想或者不能够直接引用一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用，去掉客户不能看到的内容和服务或者增添客户需要的额外服务。如在网页上查看一张图片，由于网速等原因图片不能立即显示，我们可以在图片传输过程中先把一些简单的用于描述图片的文字传输到客户端，此时这些文字就成为了图片的代理。

### 模式定义

给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做Proxy或Surrogate。代理模式是一种对象结构型模式。

### 模式结构

<div align="center">{% qnimg 微信截图_20180417131314.png alt:享元模式 %}</div>

- Subject：抽象主题角色 
- Proxy：代理主题角色 
- RealSubject：真实主题角色 

### 模式使用

- 远程（Remote）代理 
- 虚拟（Virtual）代理 
- 保护（Protect or Access）代理 
- 缓冲（Cache）代理 
- 防火墙（Firewall）代理 
- 同步化（Synchronization）代理 
- 智能引用（Smart Reference）代理

### 优缺点

- 优点
    - 代理模式能够协调调用者和被调用者，能够在一定程度上降低系统的耦合度。 
    - 当对象在远程机器上，要通过网络来生成时速度可能会很慢，此时应用代理模式可以掩盖对象在网络上生成的过程，系统的速度会加快。 
    - 对于大对象的加载(如大图片)，虚拟代理可以让加载过程在后台执行，前台使用的代理对象会使得整体运行速度得到优化。
- 缺点
    - 请求的处理速度会变慢，并且实现代理模式需要额外的工作。

### 模式应用

- 图片代理 
- AOP(Aspect Oriented Programming)

# 行为型模式

## 职责链模式(Chain of Responsibility)

使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链, 并沿着这条链传递该请求，直到有一个对象处理它为止。

### 模式背景

加薪、请假非要老总批?

- 每级领导都有一定限度的权利，对待申请，需判断是否有权来决策
- 经理可以批2天以下请假，如果没权利，向总监上报
- 总监可以批5天以下请假，如果没权利，向总经理上报

```c++
class Request   //申请
{
    //申请类别
    private string requestType;
    public string RequestType
    {
        get { return requestType; }
        set { requestType = value; }
    }

    //申请内容
    private string requestContent;
    public string RequestContent
    {
        get { return requestContent; }
        set { requestContent = value; }
    }

    //数量
    private int number;
    public int Number
    {
        get { return number; }
        set { number = value; }
    }
}
class Manager
{
    protected string name;
    public Manager(string name)
    {
        this.name = name;
    }
    public void GetResult(ManagerLevel managerLevel, Request request)
    {
        if (managerLevel == ManagerLevel.经理)
        {
            if (request.RequestType == "请假" && request.Number <= 2)
            {
                Console.WriteLine("{0}:{1} 数量{2} 被批准", name, request.RequestContent, request.Number);
            }
            else
            {
                Console.WriteLine("{0}:{1} 数量{2} 我无权处理", name, request.RequestContent, request.Number);
            }
        }
        else if (managerLevel == ManagerLevel.总监)
        {
            if (request.RequestType == "请假" && request.Number <= 5)
            {
                Console.WriteLine("{0}:{1} 数量{2} 被批准", name, request.RequestContent, request.Number);
            }
            else
            {
                Console.WriteLine("{0}:{1} 数量{2} 我无权处理", name, request.RequestContent, request.Number);
            }
        }
        else if (managerLevel == ManagerLevel.总经理)
        {
            if (request.RequestType == "请假")
            {
                Console.WriteLine("{0}:{1} 数量{2} 被批准", name, request.RequestContent, request.Number);
            }
            else if (request.RequestType == "加薪" && request.Number <= 500)
            {
                Console.WriteLine("{0}:{1} 数量{2} 被批准", name, request.RequestContent, request.Number);
            }
            else if (request.RequestType == "加薪" && request.Number > 500)
            {
                Console.WriteLine("{0}:{1} 数量{2} 再说吧", name, request.RequestContent, request.Number);
            }
        }
    }
}
static void Main(string[] args)
{
    Manager jinli = new Manager("金利");
    Manager zongjian = new Manager("宗剑");
    Manager zhongjingli = new Manager("钟精励");

    Request request = new Request();
    request.RequestType = "加薪";
    request.RequestContent = "张三请求加薪";
    request.Number = 1000;

    jinli.GetResult(ManagerLevel.经理, request);
    zongjian.GetResult(ManagerLevel.总监, request);
    zhongjingli.GetResult(ManagerLevel.总经理, request);

    Request request2 = new Request();
    request2.RequestType = "请假";
    request2.RequestContent = "张三请假";
    request2.Number = 3;

    jinli.GetResult(ManagerLevel.经理, request2);
    zongjian.GetResult(ManagerLevel.总监, request2);
    zhongjingli.GetResult(ManagerLevel.总经理, request2);

    Console.Read();
}
```

### 模式动机

- 职责链可以是一条直线、一个环或者一个树形结构，最常见的职责链是直线型，即沿着一条单向的链来传递请求。
- 链上的每一个对象都是请求处理者，职责链模式可以将请求的处理者组织成一条链，并使请求沿着链传递，由链上的处理者对请求进行相应的处理。
- 客户端无须关心请求的处理细节以及请求的传递，只需将请求发送到链上即可，将请求的发送者和请求的处理者解耦。这就是职责链模式的模式动机。

### 模式定义

避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。职责链模式又称为责任链模式，它是一种对象行为型模式。

<div align="center">{% qnimg 微信截图_20180417152941.png alt:职责链模式 %}</div>

```c++
//管理者
abstract class Manager
{
    protected string name;
    //管理者的上级
    protected Manager superior;

    public Manager(string name)
    {
        this.name = name;
    }

    //设置管理者的上级
    public void SetSuperior(Manager superior)
    {
        this.superior = superior;
    }

    //申请请求
    abstract public void RequestApplications(Request request);
}
class CommonManager : Manager    //经理
{
    public CommonManager(string name) : base(name)
    { }
    public override void RequestApplications(Request request)
    {
        if (request.RequestType == "请假" && request.Number <= 2)
        {
        Console.WriteLine("{0}:{1} 数量{2} 被批准", name, request.RequestContent, request.Number);
        }
        else
        {
            if (superior != null)
                superior.RequestApplications(request);
        }
    }
}
class Majordomo : Manager  //总监
{
    public Majordomo(string name) : base(name)
    { }
    public override void RequestApplications(Request request)
    {
        if (request.RequestType == "请假" && request.Number <= 5)
        {
        Console.WriteLine("{0}:{1} 数量{2} 被批准", name, request.RequestContent, request.Number);
        }
        else
        {
            if (superior != null)
                superior.RequestApplications(request);
        }
    }
}
class GeneralManager : Manager    //总经理
{
    public GeneralManager(string name) : base(name)
    { }
    public override void RequestApplications(Request request)
    {
        if (request.RequestType == "请假")
        {
        Console.WriteLine("{0}:{1} 数量{2} 被批准", name, request.RequestContent, request.Number);
        }
        else if (request.RequestType == "加薪" && request.Number <= 500)
        {
        Console.WriteLine("{0}:{1} 数量{2} 被批准", name, request.RequestContent, request.Number);
        }
        else if (request.RequestType == "加薪" && request.Number > 500)
        {
        Console.WriteLine("{0}:{1} 数量{2} 再说吧", name, request.RequestContent, request.Number);
        }
    }
}
static void Main(string[] args)
{
    CommonManager jinli = new CommonManager("金利");
    Majordomo zongjian = new Majordomo("宗剑");
    GeneralManager zhongjingli = new GeneralManager("钟精励");
    jinli.SetSuperior(zongjian);
    zongjian.SetSuperior(zhongjingli);

    Request request = new Request();
    request.RequestType = "请假";
    request.RequestContent = "张三请假";
    request.Number = 1;
    jinli.RequestApplications(request);

    Request request3 = new Request();
    request3.RequestType = "加薪";
    request3.RequestContent = "张三请求加薪";
    request3.Number = 500;
    jinli.RequestApplications(request3);

    Console.Read();
}
```

### 模式结构

<div align="center">{% qnimg 微信截图_20180417153731.png alt:职责链模式 %}</div>

- Handler: 抽象处理者
- ConcreteHandler: 具体处理者
- Client: 客户类

### 职责链模式和状态模式比较

- 当客户提交一个请求时，请求是沿链传递直至有一个ConcreteHander对象负责处理它。链中的对象自己并不知道链的结构，在运行时确定。结果是职责链可简化对象的相互连接，它们仅需保持一个指向其后继者的引用或指针，而不需要保持它所有的候选接受者。这也就大大降低了耦合度了。也就是说，我们可以随时地增加或修改处理一个请求的结构。增强了给对象指派职责的灵活性。
- 状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。定义新的子类可以很容易地增加新的状态和转换。这样做的目的是为了消除庞大的条件分支语句。状态模式通过把各种状态转移逻辑分布到State的子类之间，来减少相互间的依赖。
- 职责链模式与状态模式的最大的不同是设置自己的下一级的问题上，状态模式是在类的设计阶段就定好的，不能在客户端改变，而职责链的下一级是在客户端自己来确定的。
- 职责链模式注重职责的传递，由客户端配置；状态模式注重对象状态的转换，转换过程对客户端是透明的。

请假例子，找班长请假，班长只能请半天，否则班长向老师申请，如果请假时间超过一周，老师要跟副年级主任请示，如果请假超出一个月，主任要跟年级正主任请示，然后被批准，或不被批准。

问题：如果班长请假了，用状态模式，其他学生都请不了假了，也就是如果状态模式中任何一环缺失的话，这个事件都无法进行下去

职责链模式的链式是在客户端连接的，也就是说，如果我们请假，请假制度一旦改变，比如说我们不需要班长，或者是先请求老师后直接请求主任或者中间多了一个环节，都是很容易实现的，所以，职责链模式要比状态模式灵活很多。

### 优缺点

- 优点
    - 降低耦合度
    - 可简化对象的相互连接
    - 增强给对象指派职责的灵活性
    - 增加新的请求处理类很方便
- 缺点
    - 不能保证请求一定被接收。
    - 系统性能将受到一定影响，而且在进行代码调试时不太方便；可能会造成循环调用。

### 模式使用

- 有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。
- 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。
- 可动态指定一组对象处理请求

### 模式应用

**异常处理机制**

```java
try
{
    …… 			
}
catch(ArrayIndexOutOfBoundsException e1)
{
    ……
}
catch(ArithmeticException e2)
{
    ……
}
catch(IOException e3)
{
    ……
}
finally
{
    ……
}
```

### 纯与不纯的职责链模式

- 一个纯的职责链模式要求一个具体处理者对象只能在两个行为中选择一个：一个是承担责任，另一个是把责任推给下家。不允许出现某一个具体处理者对象在承担了一部分责任后又将责任向下传的情况。
- 在一个纯的职责链模式里面，一个请求必须被某一个处理者对象所接收；在一个不纯的职责链模式里面，一个请求可以最终不被任何接收端对象所接收。 

## 命令模式(Command)

将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志,以及支持可撤消的操作。

### 模式背景

去烧烤店吃烧烤, 如果客人直接和烧烤的伙计打交道, 则烧烤的伙计将直接面对各种各样的客户各种各样的需求,各种各样的口味, 而且有的客人会因为等不及而走掉,但是伙计却不知道......最后烧烤伙计手忙脚乱.

那么，我们增加一个服务员，负责接待客户，那么客人将向服务员点菜；服务员手中拿着烧烤订单纸，客人只要把自己想要的东西写上，并注明需要的口味，服务员需按客人点餐的顺序把订单放在烧烤伙计的窗台上；如果有客人退单了，那么她只需要把订单抽掉就行了；烧烤伙计则只需要看订单安心做烧烤就行了.

<div align="center">{% qnimg 微信截图_20180417155546.png alt:命令模式 %}</div>

### 模式动机

在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计，使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活。

### 模式定义

将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。

### 模式结构

<div align="center">{% qnimg 微信截图_20180417160505.png alt:命令模式 %}</div>

- Command: 抽象命令类
- ConcreteCommand: 具体命令类
- Invoker: 调用者
- Receiver: 接收者
- Client:客户类

```c++
//烤肉串者
public class Barbecuer
{
    public void BakeMutton()
    {
        Console.WriteLine("烤羊肉串!");
    }

    public void BakeChickenWing()
    {
        Console.WriteLine("烤鸡翅!");
    }
}
//抽象命令
public abstract class Command
{
    protected Barbecuer receiver;

    public Command(Barbecuer receiver)
    {
        this.receiver = receiver;
    }

    //执行命令
    abstract public void ExcuteCommand();
}

//烤羊肉串命令
class BakeMuttonCommand : Command
{
    public BakeMuttonCommand(Barbecuer receiver) : base(receiver)
    { }

    public override void ExcuteCommand()
    {
        receiver.BakeMutton();
    }
}

//服务员
public class Waiter
{
    private Command command;

    //设置订单
    public void SetOrder(Command command)
    {
        this.command = command;
    }
    //通知执行
    public void Notify()
    {
        command.ExcuteCommand();
    }
}

static void Main(string[] args)
{
    //开店前的准备
    Barbecuer boy = new Barbecuer();
    Command bakeMuttonCommand1 = new BakeMuttonCommand(boy);
    Command bakeMuttonCommand2 = new BakeMuttonCommand(boy);
    Command bakeChickenWingCommand1 = new BakeChickenWingCommand(boy);
    Waiter girl = new Waiter();

    //开门营业
    girl.SetOrder(bakeMuttonCommand1);
    girl.Notify();
    girl.SetOrder(bakeMuttonCommand2);
    girl.Notify();
    girl.SetOrder(bakeChickenWingCommand1);
    girl.Notify();

    Console.Read();

}

```

### 优缺点

- 优点
    - 降低系统的耦合度。
    - 新的命令可以很容易地加入到系统中。
    - 可以比较容易地设计一个命令队列和宏命令（组合命令）。
    - 可以方便地实现对请求的Undo和Redo。
- 缺点
    - 使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。

### 模式使用

- 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。
- 系统需要在不同的时间指定请求、将请求排队和执行请求。
- 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。
- 系统需要将一组操作组合在一起，即支持宏命令。

## 迭代器模式(Iterator)

提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。

### 模式背景

每个人都要买车票

```c++
static void Main(string[] args)
{
    ArrayList a = new ArrayList() ;
    a.Add("大鸟");
    a.Add("小菜");
    a.Add("行李");
    a.Add("老外");
    a.Add("公交内部员工");
    a.Add(“小朋友");

    foreach (string item in a)
    {
        Console.WriteLine("{0} 请买车票!", item);
    }
    Console.Read();
}
```

### 模式动机

- 一个聚合对象，如一个列表(List)或者一个集合(Set)，应该提供一种方法来让别人可以访问它的元素，而又不需要暴露它的内部结构。
- 针对不同的需要，可能还要以不同的方式遍历整个聚合对象，但是我们并不希望在聚合对象的抽象层接口中充斥着各种不同遍历的操作。
- 怎样遍历一个聚合对象，又不需要了解聚合对象的内部结构，还能够提供多种不同的遍历方式，这就是迭代器模式所要解决的问题。
- 在迭代器模式中，提供一个外部的迭代器来对聚合对象进行访问和遍历，迭代器定义了一个访问该聚合元素的接口，并且可以跟踪当前遍历的元素，了解哪些元素已经遍历过而哪些没有。
- 有了迭代器模式，我们会发现对一个复杂的聚合对象的操作会变得如此简单。

### 模式定义

提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标(Cursor)。迭代器模式是一种对象行为型模式。

### 模式结构

<div align="center">{% qnimg 微信截图_20180417162005.png alt:迭代器模式 %}</div>

- Iterator: 抽象迭代器
- ConcreteIterator: 具体迭代器
- Aggregate: 抽象聚合类
- ConcreteAggregate: 具体聚合类

```c++
abstract class Iterator
{
    public abstract object First();
    public abstract object Next();
    public abstract bool IsDone();
    public abstract object CurrentItem();
}
abstract class Aggregate
{
    public abstract Iterator CreateIterator();
}
class ConcreteAggregate : Aggregate
{
    private IList<object> items = new List<object>();
    public override Iterator CreateIterator()
    {
        return new ConcreteIterator(this);
    }

    public int Count
    {
        get { return items.Count; }
    }

    public object this[int index]
    {
        get { return items[index]; }
        set { items.Insert(index, value); }
    }
}
class ConcreteIterator : Iterator
{
    private ConcreteAggregate aggregate;
    private int current = 0;
    public ConcreteIterator(ConcreteAggregate aggregate)
    {
        this.aggregate = aggregate;
    }
    public override object First()
    {
        return aggregate[0];
    }
    public override object Next()
    {
        object ret = null;
        current++;
        if (current < aggregate.Count)
        {
            ret = aggregate[current];
        }
        return ret;
    }
    public override object CurrentItem()
    {
        return aggregate[current];
    }
    public override bool IsDone()
    {
        return current >= aggregate.Count ? true : false;
    }
}
static void Main(string[] args)
{
    ConcreteAggregate a = new ConcreteAggregate();
    a[0] = "大鸟";
    a[1] = "小菜";
    a[2] = "行李";
    a[3] = "老外";
    a[4] = "公交内部员工";
    a[5] = "小朋友";
    Iterator i = a.CreateIterator();
    object item = i.First();
    while (!i.IsDone())
    {
        Console.WriteLine("{0} 请买车票!", i.CurrentItem());
        i.Next();
    }
    Console.Read();
}
```

### 索引器

索引器允许类和结构的实例用下标进行访问，这种方式类似于访问数组、集合的元素，但不单单是通过下标，例如通过对象的各属性值也是可以的。索引器写在类或者结构中，其格式类似于：

```c++
public object this[int index]
{
    get { return objects[int]; }
    set { objects[int] = value; }
}
```

索引器是特殊的属性，可以有get、set访问器，可以重载。object是返回的对象类型，this代表类或结构自己，int index表示索引类型。这与索引器的调用格式：对象[索引]，相对应。

```c++
public class Car
{
    /// <summary>
    /// 品牌
    /// </summary>
    public string Brand { get; set; }

    /// <summary>
    /// 颜色
    /// </summary>
    public string Color { get; set; }

    /// <summary>
    /// 覆盖object的ToString()方法
    /// </summary>
    /// <returns></returns>
    public override string ToString()
    {
        return string.Format("A {0} {1}.", this.Color, this.Brand);
    }
}
public class Cars
{
    public IList<Car> List { get; set; }
    /// <summary>
    /// 用下标访问的索引器
    /// </summary>
    /// <param name="index">下标</param>
    /// <returns>汽车</returns>
    public Car this[int index]
    {
        get { return this.List[index]; }
    }
    /// <summary>
    /// 用品牌访问的索引器
    /// </summary>
    /// <param name="brand">品牌</param>
    /// <returns>汽车</returns>
    public Car this[string brand]
    {
        get
        {
            for (int i = 0; i < List.Count; i+
                if (brand.Equals(this.List[i].Brand))
                return this.List[i];
            return null;
        }
    }
}

public static void Main(string[] args)
{
    Cars cars = new Cars
    {
        List = new List<Car>
        {
            new Car { Brand = "BMW", Color = "Black" },     // 黑色宝马
            new Car { Brand = "Benz", Color = "Red" },      // 红色奔驰
            new Car { Brand = "Porsche", Color = "Yellow" } // 黄色保时捷
        }
    };
     
    Console.Title = "索引器";
    Console.WriteLine(cars[0].ToString());
    Console.WriteLine(cars["Porsche"].ToString());
     
    Console.ReadLine();
}
```

### 优缺点

- 优点
    - 它支持以不同的方式遍历一个聚合对象。
    - 迭代器简化了聚合类。
    - 在同一个聚合上可以有多个遍历。
    - 在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足“开闭原则”的要求。
- 缺点
    - 由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。

### 模式使用

- 访问一个聚合对象的内容而无须暴露它的内部表示。
- 需要为聚合对象提供多种遍历方式。
- 为遍历不同的聚合结构提供一个统一的接口。

## 中介者模式(Mediator)

用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

<div align="center">{% qnimg 微信截图_20180417165036.png alt:中介者模式 %}</div>

系统将出现如下问题

- 系统结构复杂：对象之间存在大量的相互关联和调用，若有一个对象发生变化，则需要跟踪和该对象关联的其他所有对象，并进行适当处理。
- 对象可重用性差：由于一个对象和其他对象具有很强的关联，若没有其他对象的支持，一个对象很难被另一个系统或模块重用，这些对象表现出来更像一个不可分割的整体，职责较为混乱。
- 系统扩展性低：增加一个新的对象需要在原有相关对象上增加引用，增加新的引用关系也需要调整原有对象，系统耦合度很高，对象操作很不灵活，扩展性差。

### 模式动机

- 在面向对象的软件设计与开发过程中，根据“单一职责原则”，我们应该尽量将对象细化，使其只负责或呈现单一的职责。
- 对于一个模块，可能由很多对象构成，而且这些对象之间可能存在相互的引用，为了减少对象两两之间复杂的引用关系，使之成为一个松耦合的系统，我们需要使用中介者模式，这就是中介者模式的模式动机。

### 模式定义

用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。

### 模式结构

<div align="center">{% qnimg 微信截图_20180417165436.png alt:中介者模式 %}</div>

- Mediator: 抽象中介者
- ConcreteMediator: 具体中介者
- Colleague: 抽象同事类
- ConcreteColleague: 具体同事类

```c++
abstract class Colleague
{
    protected Mediator mediator;

    public Colleague(Mediator mediator)
    {
        this.mediator = mediator;
    }
}
abstract class Mediator
{
    public abstract void Send(string message, Colleague colleague);
}
class ConcreteColleague1 : Colleague
{
    public ConcreteColleague1(Mediator mediator) : base(mediator)
    {
    }
    public void Send(string message)
    {
        mediator.Send(message, this);
    }
    public void Notify(string message)
    {
        Console.WriteLine("同事1得到信息:" + message);
    }
}
class ConcreteColleague2 : Colleague
{
    public ConcreteColleague2(Mediator mediator) : base(mediator)
    {
    }
    public void Send(string message)
    {
        mediator.Send(message, this);
    }
    public void Notify(string message)
    {
        Console.WriteLine("同事2得到信息:" + message);
    }
}
class ConcreteMediator : Mediator
{
    private ConcreteColleague1 colleague1;
    private ConcreteColleague2 colleague2;

    public ConcreteColleague1 Colleague1
    {
        set { colleague1 = value; }
    }

    public ConcreteColleague2 Colleague2
    {
        set { colleague2 = value; }
    }

    public override void Send(string message, Colleague colleague)
    {
        if (colleague == colleague1)
        {
            colleague2.Notify(message);
        }
        else
        {
            colleague1.Notify(message);
        }
    }
}
static void Main(string[] args)
{
    ConcreteMediator m = new ConcreteMediator();

    ConcreteColleague1 c1 = new ConcreteColleague1(m);
    ConcreteColleague2 c2 = new ConcreteColleague2(m);

    m.Colleague1 = c1;
    m.Colleague2 = c2;

    c1.Send("吃过饭了吗?");
    c2.Send("没有呢，你打算请客？");

    Console.Read();
}
```

### 优缺点

- 优点
    - 简化了对象之间的交互。
    - 将各同事解耦。
    - 减少子类生成。
    - 可以简化各同事类的设计和实现。
- 缺点
    - 在具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。

### 模式使用

- 系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解。
- 一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象。
- 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象交互的公共行为，如果需要改变行为则可以增加新的中介者类。

### 模式应用

- 中介者模式与迪米特法则
- 在中介者模式中，通过创造出一个中介者对象，将系统中有关的对象所引用的其他对象数目减少到最少，使得一个对象与其同事之间的相互作用被这个对象与中介者对象之间的相互作用所取代。因此，中介者模式就是迪米特法则的一个典型应用。

## 备忘录模式(Memento)

在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。

### 模式背景

我要保存游戏进度

- 游戏角色，生命力、攻击力、防御力
- 模拟战斗代码，读取进度

```c++
class GameRole
{
    //生命力
    private int vit;
    public int Vitality
    {
        get { return vit; }
        set { vit = value; }
    }

    //攻击力
    private int atk;
    public int Attack
    {
        get { return atk; }
        set { atk = value; }
    }

    //防御力
    private int def;
    public int Defense
    {
        get { return def; }
        set { def = value; }
    }
    //状态显示
    public void StateDisplay()
    {
        Console.WriteLine("角色当前状态：");
        Console.WriteLine("体力：{0}", this.vit);
        Console.WriteLine("攻击力：{0}", this.atk);
        Console.WriteLine("防御力：{0}", this.def);
        Console.WriteLine("");
    }

    //获得初始状态
    public void GetInitState()
    {
        this.vit = 100;
        this.atk = 100;
        this.def = 100;
    }

    //战斗
    public void Fight()
    {
        this.vit = 0;
        this.atk = 0;
        this.def = 0;
    }
}

static void Main(string[] args)
{
    //大战Boss前
    GameRole lixiaoyao = new GameRole();
    lixiaoyao.GetInitState();
    lixiaoyao.StateDisplay();

    //保存进度
    GameRole backup = new GameRole();
    backup.Vitality = lixiaoyao.Vitality;
    backup.Attack = lixiaoyao.Attack;
    backup.Defense = lixiaoyao.Defense;

    //大战Boss时，损耗严重
    lixiaoyao.Fight();
    lixiaoyao.StateDisplay();

    //恢复之前状态
    lixiaoyao.Vitality = backup.Vitality;
    lixiaoyao.Attack = backup.Attack;
    lixiaoyao.Defense = backup.Defense;

    lixiaoyao.StateDisplay();
    Console.Read();
}

```

### 模式动机

- 在应用软件的开发过程中，有时我们有必要记录一个对象的内部状态。为了允许用户取消不确定的操作或从错误中恢复过来，需要实现备份点和撤销机制，而要实现这些机制，我们必须事先将状态信息保存在某处，这样状态才能将对象恢复到它们原先的状态。
- 但是对象通常封装了其部分或所有的状态信息，使得其状态不能被其它对象访问，也就不可能在该对象之外保存其状态，而暴露其内部状态又将违反封装的原则，可能有损系统的可靠性和可扩展性。

### 模式定义

在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。

<div align="center">{% qnimg 微信截图_20180417173923.png alt:备忘录模式 %}</div>

```c++
class GameRole
{
    ……
    
    //保存角色状态
    public RoleStateMemento SaveState()
    {
        return (new RoleStateMemento(vit, atk, def));
    }

    //恢复角色状态
    public void RecoveryState(RoleStateMemento memento)
    {
        this.vit = memento.Vitality;
        this.atk = memento.Attack;
        this.def = memento.Defense;
    }

    ……
}

class RoleStateMemento    //角色状态存储箱
{
    private int vit;
    private int atk;
    private int def;

    public RoleStateMemento(int vit, int atk, int def)
    {
        this.vit = vit;
        this.atk = atk;
        this.def = def;
    }

    public int Vitality   //生命力
    {
        get { return vit; }
        set { vit = value; }
    }

    public int Attack   //攻击力
    {
        get { return atk; }
        set { atk = value; }
    }

    public int Defense    //防御力
    {
        get { return def; }
        set { def = value; }
    }
}
//角色状态管理者
class RoleStateCaretaker
{
    private RoleStateMemento memento;

    public void ImportState(RoleStateMemento Record)
    {
        memento = Record;
    }

    public RoleStateMemento ExportState()
    {
        return memento;
    }
}

static void Main(string[] args)
{
    //大战Boss前
    GameRole lixiaoyao = new GameRole();
    lixiaoyao.GetInitState();
    lixiaoyao.StateDisplay();
    
    //保存进度
    RoleStateCaretaker stateAdmin = new RoleStateCaretaker();
    stateAdmin.ImportState(lixiaoyao.SaveState());

    //大战Boss时，损耗严重
    lixiaoyao.Fight();
    lixiaoyao.StateDisplay();

    //恢复之前状态
    lixiaoyao.RecoveryState(stateAdmin.ExportState());
    lixiaoyao.StateDisplay();

    Console.Read();        
}
```

### 模式结构

<div align="center">{% qnimg 微信截图_20180417174524.png alt:备忘录模式 %}</div>

- Originator：原发器 
- Memento：备忘录 
- Caretaker：负责人

### 优缺点

- 优点
    - 备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原。 
    - 备忘录模式保存了封装的边界信息，Memento对象是原发器对象的表示，不会被其它代码改动，这种模式简化了原发器对象，Memento只保存原发器的状态，采用堆栈来存储备忘录对象可以实现多次取消操作。
- 缺点
    - 资源消耗过大，如果类的成员变量太多，就不可避免占用大量的内存了，而且每保存一次对象的状态都需要消耗内存资源，如果知道这一点大家就容易理解为什么一些提供了Undo功能的软件在运行时需要的内存和硬盘空间比较大了。

### 模式使用

- 必须保存一个对象在某一个时刻的状态/部分状态，这样以后需要时它能够恢复到先前的状态。 
- 如果一个用接口来让其它对象得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。

### 模式应用

- Undo功能 
- 配置文件 
- Cookie Session对象 

## 观察者模式(Observer)

定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

### 模式背景

晕，老板回来了，我不知道

- 股市特别火，同事在上班期间偷偷看股票行情
- 如果老板出门回来，公司前台MM电话事先通知
- 可是…..
- 老板今天刚一回来，让前台MM去打印资料了
- 同事背对着大门大喊了一声“耶！我的股票涨停啦！”
- 程序模拟发生的事情

```c++
class Secretary   //前台秘书类
{
    //同事列表
    private IList<StockObserver> observers = new List<StockObserver>();
    private string action;
    //增加
    public void Attach(StockObserver observer)
    {
        observers.Add(observer);
    }
    //减少
    public void Detach(StockObserver observer)
    {
        observers.Remove(observer);
    }
    //通知
    public void Notify()
    {
        foreach (StockObserver o in observers)
            o.Update();
    }
    //前台状态
    public string SecretaryAction
    {
        get { return action; }
        set { action = value; }
    }
}
//看股票的同事
class StockObserver
{
    private string name;
    private Secretary sub;

    public StockObserver(string name, Secretary sub)
    {
        this.name = name;
        this.sub = sub;
    }

    public void Update()
    {
        Console.WriteLine("{0} {1} 关闭股票行情，继续工作！", sub.SecretaryAction, name);
    }
}
static void Main(string[] args)
{
    //前台秘书MM
    Secretary MM = new Secretary();
    //看股票的同事
    StockObserver tongshi1 = new StockObserver("魏关姹", MM);
    StockObserver tongshi2 = new StockObserver("易管查", MM);

    //前台记下了两位同事
    MM.Attach(tongshi1);
    MM.Attach(tongshi2);
    //发现老板回来
    MM.SecretaryAction = "老板回来了！";
    //通知两个同事
    MM.Notify();

    Console.Read();
}
```

如果有人聊QQ，有人看NBA都需要通知，如何修改？思考：违背了那些原则？

```c++
//抽象观察者
abstract class Observer
{
    protected string name;
    protected Secretary sub;

    public Observer(string name, Secretary sub)
    {
        this.name = name;
        this.sub = sub;
    }

    public abstract void Update();
}
//看股票的同事
class StockObserver : Observer
{
    public StockObserver(string name, Secretary sub) : base(name, sub)
    {
    }
    public override void Update()
    {
        Console.WriteLine("{0} {1} 关闭股票行情，继续工作！", sub.SecretaryAction, name);
    }
}

//看NBA的同事
class NBAObserver : Observer
{
    public NBAObserver(string name, Secretary sub)  : base(name, sub)
    {
    }
    public override void Update()
    {
        Console.WriteLine("{0} {1} 关闭NBA直播，继续工作！", sub.SecretaryAction, name);
    }
}

class Secretary    //前台秘书类
{
    //同事列表
    private IList<Observer> observers = new List<Observer>();
    private string action;

    //增加
    public void Attach(Observer observer)
    {
        observers.Add(observer);
    }

    //减少
    public void Detach(Observer observer)
    {
        observers.Remove(observer);
    }

    //通知
    public void Notify()
    {
        foreach (Observer o in observers)
            o.Update();
        ….. 
    }
}
```

其实作为通知者，老板、秘书、所有人都可以成为通知者，应该抽象出来

```c++
//通知者接口
interface Subject
{
    void Attach(Observer observer);
    void Detach(Observer observer);
    void Notify();
    string SubjectState
    {
        get;
        set;
    }
}
class Secretary : Subject
{
    //同事列表
    private IList<Observer> observers = new List<Observer>();
    private string action;
    //增加
    public void Attach(Observer observer)
    {
        observers.Add(observer);
    }
    //减少
    public void Detach(Observer observer)
    {
        observers.Remove(observer);
    }
    //通知
    public void Notify()
    {
        foreach (Observer o in observers)
            o.Update();
    }
    //前台状态
    public string SubjectState
    {
        get { return action; }
        set { action = value; }
    }
}
class Boss : Subject
{
    //同事列表
    private IList<Observer> observers = new List<Observer>();
    private string action;
    //增加
    public void Attach(Observer observer)
    {
        observers.Add(observer);
    }
    //减少
    public void Detach(Observer observer)
    {
        observers.Remove(observer);
    }
    //通知
    public void Notify()
    {
        foreach (Observer o in observers)
            o.Update();
    }
    //老板状态
    public string SubjectState
    {
        get { return action; }
        set { action = value; }
    }
}
static void Main(string[] args)
{
    //老板胡汉三
    Boss huhansan = new Boss();

    //看股票的同事
    StockObserver tongshi1 = new StockObserver("魏关姹", huhansan);
    //看NBA的同事
    NBAObserver tongshi2 = new NBAObserver("易管查", huhansan);

    huhansan.Attach(tongshi1);
    huhansan.Attach(tongshi2);

    huhansan.Detach(tongshi1);

    //老板回来
    huhansan.SubjectState = "我胡汉三回来了！";
    //发出通知
    huhansan.Notify();

    Console.Read();
}
```

<div align="center">{% qnimg 微信截图_20180417181530.png alt:观察者模式 %}</div>

### 模式动机

建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展，这就是观察者模式的模式动机。

### 模式定义

- 观察者模式(Observer Pattern)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。
- 观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。观察者模式是一种对象行为型模式。

### 模式结构

<div align="center">{% qnimg 微信截图_20180417235401.png alt:观察者模式 %}</div>

- Subject：目标（被观察对象） 
- ConcreteSubject：具体目标 
- Observer：观察者 
- ConcreteObserver：具体观察者

注册的投资者在股票市场发生变化时，可以自动得到通知

```c++
abstract class Stock
{
    // Fields
    protected string symbol;
    protected double price;
    private ArrayList investors = new ArrayList();

    // Constructor
    public Stock( string symbol, double price )
    {
        this.symbol = symbol;
        this.price = price;
    }
    
    // Properties
    public double Price
    {
        get{ return price; }
        set
        {
            price = value;
            Notify(); 
        }
    }

    public string Symbol
    {
        get{ return symbol; }
        set{ symbol = value; }
    }

    // Methods
    public void Attach( Investor investor )
    {
        investors.Add( investor );
    }

    public void Detach( Investor investor )
    {
        investors.Remove( investor );
    }

    public void Notify()
    {
        foreach( Investor i in investors )
        i.Update( this );
    }
  
}


// "ConcreteSubject"
class IBM : Stock
{
    // Constructor
    public IBM( string symbol, double price )
        : base( symbol, price ) {}
}

// "Observer"
interface IInvestor
{
    // Methods
    void Update( Stock stock );
}

// "ConcreteObserver"
class Investor : IInvestor
{
    // Fields
    private string name;
    private string observerState;
    private Stock stock;

    // Constructors
    public Investor( string name )
    {
        this.name = name;
    }

    // Methods
    public void Update( Stock stock )
    {
        Console.WriteLine( "Notified investor {0} of {1}'s change to {2:C}", 
        name, stock.Symbol, stock.Price );
    }

    // Properties
    public Stock Stock
    {
        get{ return stock; }
        set{ stock = value; }
    }
}

public static void Main( string[] args )
{
    // Create investors
    Investor s = new Investor( "Sorros" );
    Investor b = new Investor( "Berkshire" );

    // Create IBM stock and attach investors
    IBM ibm = new IBM( "IBM", 120.00 );
    ibm.Attach( s );
    ibm.Attach( b );

    // Change price, which notifies investors
    ibm.Price = 120.10;
    ibm.Price = 121.00;
    ibm.Price = 120.50;
    ibm.Price = 120.75;
}

```

### 模式分析

- 观察者模式描述了如何建立对象与对象之间的依赖关系，如何构造满足这种需求的系统。
- 这一模式中的关键对象是观察目标和观察者，一个目标可以有任意数目的与之相依赖的观察者，一旦目标的状态发生改变，所有的观察者都将得到通知。
- 作为对这个通知的响应，每个观察者都将即时更新自己的状态，以与目标状态同步，这种交互也称为发布-订阅(publish-subscribe)。目标是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通知。

### 优缺点

- 优点
- 观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。
- 观察者模式在观察目标和观察者之间建立一个抽象的耦合。 
- 观察者模式支持广播通信。
- 观察者模式符合“开闭原则”的要求。
- 缺点
- 如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。
- 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。
- 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

### 模式使用

- 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。
- 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。
- 一个对象必须通知其他对象，而并不知道这些对象是谁。
- 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。

### 模式应用

- JDK1.1版本及以后的各个版本中，事件处理模型采用基于观察者模式的委派事件模型(Delegation Event Model, DEM)。
- 在DEM中，事件的发布者称为事件源(Event Source)，而订阅者叫做事件监听器(Event Listener)，在这个过程中还可以通过事件对象(Event Object)来传递与事件相关的信息，事件源对象、事件监听对象（事件处理对象）和事件对象构成了Java事件处理模型的三要素。
- 观察者模式在软件开发中应用非常广泛，如某电子商务网站可以在执行发送操作后给用户多个发送商品打折信息，某团队战斗游戏中某队友牺牲将给所有成员提示等等，凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式。 

## 状态模式(State)

当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。

### 模式背景

又要加班了?(工作状态函数)

- 上午工作状态 ( h<12点 )
- 中午工作状态 ( 12<h<13点 )
- 下午工作状态 ( 13<h<17点 )
- 晚间工作状态 ( 17<h<21点 )
- 睡眠状态 ( h>21 点 )
- 下班状态

```c++
public static void WriteProgram()
{
    if (Hour < 12)
    {
        Console.WriteLine("当前时间：{0}点 上午工作，精神百倍", Hour);
    }
    else if (Hour < 13)
    {
        Console.WriteLine("当前时间：{0}点 饿了，午饭；犯困，午休。", Hour);
    }
    else if (Hour < 17)
    {
        Console.WriteLine("当前时间：{0}点 下午状态还不错，继续努力", Hour);
    }
    else
    {
        if (WorkFinished)
        {
            Console.WriteLine("当前时间：{0}点 下班回家了", Hour);
        }
        else
        {
            if (Hour < 21)
            {
                Console.WriteLine("当前时间：{0}点 加班哦，疲累之极", Hour);
            }
            else
            {
                Console.WriteLine("当前时间：{0}点 不行了，睡着了。", Hour);
            }
        }
    }
}

static int Hour = 0;
static bool WorkFinished = false; 

static void Main(string[] args)
{
    Hour = 9;
    WriteProgram();
    Hour = 10;
    WriteProgram();
    Hour = 12;
    WriteProgram();
    Hour = 13;
    WriteProgram();
    Hour = 14;
    WriteProgram();
    Hour = 17;

    WorkFinished = true; // false;

    WriteProgram();
    Hour = 19;
    WriteProgram();
    Hour = 22;
    WriteProgram();

    Console.Read();
}
```

面向过程的思维，通过面向对象完成代码的责任分解

```c++
public class Work   //工作
{
    //钟点
    private int hour;
    public int Hour
    {
        get { return hour; }
        set { hour = value; }
    }

    //任务完成
    private bool finish = false;
    public bool TaskFinished
    {
        get { return finish; }
        set { finish = value; }
    }


    public void WriteProgram()
    {
        ……
    }
}

static void Main(string[] args)
{
    Work MisProject = new Work();
    MisProject.Hour = 10;
    MisProject.WriteProgram();

    Work MisProject = new Work();
    MisProject.Hour = 13;
    MisProject.WriteProgram();

    Work MisProject = new Work();
    MisProject.Hour = 16;
    MisProject.WriteProgram();

    Console.Read();
}

```

过多的判断分支，说明类的责任过大，无论何种状态改变，都需要通过它来改变，违背的原则？

### 模式动机

- 在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的(stateful)对象。这样的对象状态是从事先定义好的一系列值中取出的。当一个这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化。
- 考虑一个银行系统，一个账户对象的状态处于若干个不同状态之一：开户状态、正常状态、透支状态、冻结状态。当顾客在对账户进行存取款操作时，账户类根据自身的当前状态作出不同的反应，同时进行对象状态的切换。例如：如果账户处于冻结状态就没有办法再进行取款操作，一个取款操作需要先了解账户对象的状态。
- 状态(State)模式描述了账户如何在每一种状态下表现出不同的行为。而一旦取款操作完成，对象的状态也将动态发生变化，如取款后账户余额低于某一值其状态可能从正常状态转为透支状态。
- 状态模式的关键是引入了一个抽象类来专门表示对象的状态，这个类我们叫做状态类，而对象的具体状态都继承了该类，并在不同具体状态类中实现了不同状态的行为，包括各种状态之间的转换。

### 模式定义

允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Objects for States)。状态模式是一种对象行为型模式。

当一个对象的行为取决于它的状态，并且在运行时需要根据状态改变行为的时候，将特定状态的相关行为放到一个对象中，可以通过定义新的子类增加新的状态和转换。

<div align="center">{% qnimg 微信截图_20180418005947.png alt:状态模式 %}</div>

```c++
public class Work    //工作
{
    private State current;
    public Work()
    {
        current = new ForenoonState();
    }

    private double hour;
    public double Hour
    {
        get { return hour; }
        set { hour = value; }
    }

    private bool finish = false;
    public bool TaskFinished
    {
        get { return finish; }
        set { finish = value; }
    }

    public void SetState(State s)
    {
        current = s;
    }

    public void WordHard()
    {
        current.WriteProgram(this);
    }
}

public abstract class State     //抽象状态
{
    public abstract void WriteProgram(Work w);
}
public class ForenoonState : State     //上午工作状态
{
    public override void WriteProgram(Work w)
    {
        if (w.Hour < 12)
        {
            Console.WriteLine("当前时间：{0}点 上午工作，精神百倍", w.Hour);
        }
        else
        {
            w.SetState(new NoonState());
            w.WorkHard();
        }
    }
}
public class NoonState : State     //中午工作状态
{
    public override void WriteProgram(Work w)
    {
        if (w.Hour < 13)
        {
            Console.WriteLine("当前时间：{0}点 饿了，午饭；犯困，午休。", w.Hour);
        }
        else
        {
            w.SetState(new AfternoonState());
            w.WorkHard();
        }
    }
}

static void Main(string[] args)
{
    //紧急项目
    Work EmProject = new Work();
    EmProject.Hour = 9;
    EmProject.WorkHard();
    EmProject.Hour = 10;
    EmProject.WorkHard();
    EmProject.Hour = 12;
    EmProject.WorkHard();
    EmProject.Hour = 13;
    EmProject.WorkHard();
    EmProject.Hour = 14;
    EmProject.WorkHard();
    EmProject.Hour = 17;

    EmProject.TaskFinished = true;
    // EmProject.TaskFinished = false;

    EmProject.WriteProgram();
    EmProject.Hour = 19;
    EmProject.WriteProgram();
    EmProject.Hour = 22;
    EmProject.WriteProgram();

    Console.Read();
}

```

### 模式结构

<div align="center">{% qnimg 微信截图_20180418010557.png alt:状态模式 %}</div>

- Context：环境类 
- State：抽象状态类 
- ConcreteState：具体状态类

```c++
public class Context
{
    private State state;
    
    public Context(State state)
    {
        this.state = state;
    }

    public State State
    {
        get { return state; }
        set { state = value; }
    }

    public void Request()
    {
        state.Handle(this);
    }
}
public abstract class State
{
    public abstract void Handle(Context context);
}
public class ConcreteStateA : State
{
    public override void Handle(Context context)
    {
        Console.WriteLine("当前状态是 A.");
        context.State = new ConcreteStateB();
    }
}

public class ConcreteStateB : State
{
    public override void Handle(Context context)
    {
        Console.WriteLine("当前状态是 B.");
        context.State = new ConcreteStateA();
    }
}

class Program
{
    static void Main(string[] args)
    {
        // 设置Context的初始状态为ConcreteStateA
        Context context = new Context(new ConcreteStateA());

        // 不断地进行请求，同时更改状态
        context.Request();
        context.Request();
        context.Request();
        context.Request();

        Console.Read();
    }
}

```

### 模式应用

- 灯泡的开与关
- qq在线状态
- 文档编辑器状态切换
- 工作流系统 
- 游戏开发

### 优缺点

- 优点
    - 封装转换过程，也就是转换规则。 
    - 枚举可能的状态，因此，需要事先确定状态种类。 
    - 将所有与某个状态有关的行为放到一个对象里。 
    - 允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块或switch语句。 
    - 避免了状态的不一致性，因为状态的改变只使用一个状态对象而不是几个对象或属性。
- 缺点
    - 状态模式的使用必然会增加系统类和对象的个数。

### 模式使用

- 对象的行为依赖于它的状态（属性）并且它必须可以根据它的状态改变而改变它的相关行为。
- 操作的很多部分都带有与对象状态有关的大量条件语句，大量条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加删除状态，使客户类与类库之间的耦合增强。

## 策略模式(Strategy)

定义一系列的算法,把它们一个个封装起来,并且使它们可相互替换。

## 模板方法模式(Template Method)

定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。TemplateMethod使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

## 访问者模式(Visitor)

表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

## 解释器模式(Interpreter)

给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。